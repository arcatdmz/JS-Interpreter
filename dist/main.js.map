{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./src/Interpreter.ts","webpack:///./node_modules/acorn/acorn.js","webpack:///./src/MyState.ts","webpack:///./src/MyObject.ts"],"names":["root","factory","exports","module","define","amd","a","i","global","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Interpreter","code","opt_initFunc","acorn","parse","PARSE_OPTIONS","this","ast","initFunc_","paused_","polyfills_","functionCounter_","stepFunctions_","stepMatch","props","getOwnPropertyNames","length","methodName","match","state","createScope","join","undefined","stripLocations_","MyState","done","stateStack","run","nodeConstructor","node","constructor","OBJECT","OBJECT_PROTO","FUNCTION","FUNCTION_PROTO","ARRAY","ARRAY_PROTO","REGEXP","REGEXP_PROTO","NaN","Error","populateScope_","scope","push","stack","type","nextState","e","STEP_ERROR","step","setProperty","READONLY_DESCRIPTOR","Infinity","MyObject","initFunction","initObject","proto","initArray","initMap","initSet","initString","initBoolean","initNumber","initDate","initRegExp","initError","initMath","initJSON","thisInterpreter","func","createNativeFunction","x","EvalError","eval","parseInt","parseFloat","isNaN","isFinite","strFunctions","escape","unescape","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","wrapper","nativeFunc","str","throwException","URI_ERROR","message","NONENUMERABLE_DESCRIPTOR","identifierRegexp","var_args","calledWithNew","newFunc","createObjectProto","arguments","String","args","SYNTAX_ERROR","parentScope","id","boxThis","isObject","getScope","strict","box","getPrototype","data","thisArg","func_","funcThis_","arguments_","pseudoToNative","TYPE_ERROR","doneExec_","setNativeFunctionPrototype","toString","valueOf","throwIfNullUndefined","obj","properties","nativeToPseudo","keys","prop","descriptor","preventExtensions","ReferenceError","getOwnPropertyDescriptor","setter","set","writable","pseudoDescriptor","Boolean","propertyIsEnumerable","newArray","first","legalArrayLength","RANGE_ERROR","class","Array","pop","apply","shift","unshift","reverse","index","howmany","list","splice","opt_begin","opt_end","slice","opt_separator","iLength","getProperty","hasProperty","element","isa","jLength","j","searchElement","opt_fromIndex","indexOf","lastIndexOf","sort","newMap","MAP_PROTO","entries","pair","size","MAP","keyToDelete","keyToFind","Map","map","kv","iterator","newSet","SET_PROTO","SET","valueToDelete","v","STRING","fromCharCode","functions","compareString","locales","options","localeCompare","separator","limit","jsList","split","regexp","search","substr","newSubstr","replace","BOOLEAN","Number","NUMBER","numConsts","READONLY_NONENUMERABLE_DESCRIPTOR","fractionDigits","toExponential","ERROR","digits","toFixed","precision","toPrecision","radix","toLocaleString","Date","concat","Function","DATE","now","UTC","pattern","flags","rgx","populateRegExp","RegExp","test","lastIndex","exec","result","input","opt_message","newError","createObject","createErrorSubclass","EVAL_ERROR","REFERENCE_ERROR","myMath","mathConsts","Math","numFunctions","myJSON","text","nativeObj","JSON","stringify","child","childObj","configurable","pseudoRegexp","nativeRegexp","source","ignoreCase","multiline","opt_constructor","illegalConstructor","asyncFunc","interpreter","pseudoObj","isArray","opt_cycles","cycles","pseudo","native","val","charCodeAt","legalArrayIndex","myObj","isGetter","TypeError","opt_descriptor","max","defObj","initGlobalScope","firstNode","expression","opt_scope","prevNode","VARIABLE_DESCRIPTOR","createFunction","nodeClass","start","end","isConstructor","ref","SCOPE_REFERENCE","getValueFromScope","setValueToScope","errorClass","error","executeException","throwValue","realError","errorTable","RangeError","SyntaxError","URIError","left","funcThis","doneCallee_","doneArgs_","elements","n_","array_","doneLeft_","components","doneRight_","leftReference_","doneGetter_","leftValue_","leftValue","getValue","createGetter_","doneSetter_","rightValue","setValue","createSetter_","label","labels","isLoop","isSwitch","funcNode","paramName","paramValue","argsList","evalNode","argsWithCallback","done_","createSpecialScope","mode_","test_","doneInit_","doneObject_","variable_","object_","visited_","name_","props_","doneVariable_","isIterable","next","itr_","from","filter","stepConditionalExpression","propName","doneProperty_","stepCallExpression","properties_","kinds","switchValue_","index_","switchCase","matched_","defaultCase_","tested_","doneBlock_","doneHandler_","doneFinalizer_","leftSide_","changeValue","returnValue","declarations","declarationNode","init_","doneBody_","stepDoWhileStatement","ecmaVersion","toStringCycles_","console","log","inputLen","sourceFile","version","inpt","opts","setOptions","initTokenState","program","lastStart","lastEnd","tokPos","locations","lastEndLoc","line_loc_t","inFunction","readToken","startNode","body","tokType","_eof","stmt","parseStatement","isUseStrict","setStrict","finishNode","parseTopLevel","defaultOptions","strictSemicolons","allowTrailingCommas","forbidReserved","onComment","ranges","directSourceFile","opt","tokStart","tokEnd","tokStartLoc","tokEndLoc","tokVal","tokRegexpAllowed","tokCurLine","tokLineStart","getLineInfo","offset","line","cur","lineBreak","column","raise","pos","loc","err","raisedAt","tokenize","getToken","forceRegexp","startLoc","endLoc","jumpTo","reAllowed","skipSpace","empty","_num","_regexp","_string","_name","_break","keyword","_case","beforeExpr","_catch","_continue","_debugger","_default","_do","_else","_finally","_for","_function","_if","_return","_switch","_throw","_try","_var","_while","_with","_new","_this","_null","atomValue","_true","_false","_in","binop","keywordTypes","prefix","_bracketL","_bracketR","_braceL","_braceR","_parenL","_parenR","_comma","_semi","_colon","_dot","_question","_slash","_eq","isAssign","_assign","_incDec","postfix","isUpdate","_prefix","_logicalOR","_logicalAND","_bitwiseOR","_bitwiseXOR","_bitwiseAND","_equality","_relational","_bitShift","_plusMin","_multiplyModulo","kw","tokTypes","bracketL","bracketR","braceL","braceR","parenL","parenR","comma","semi","colon","dot","question","slash","eq","eof","num","string","makePredicate","words","f","cats","out","compareTo","arr","b","cat","containsEsc","isReservedWord3","isReservedWord5","isStrictReservedWord","isStrictBadIdWord","isKeyword","nonASCIIwhitespace","nonASCIIidentifierStartChars","nonASCIIidentifierStart","nonASCIIidentifier","newline","isIdentifierStart","isIdentifierChar","finishToken","skipBlockComment","skipLineComment","ch","getTokenFromCode","readNumber","readToken_dot","readInt","readHexNumber","quote","octal","readHexChar","readString","readRegexp","finishOp","readToken_slash","readToken_pipe_amp","readToken_plus_min","readToken_lt_gt","readToken_eq_excl","readWord","tok","escaped","inClass","charAt","content","mods","readWord1","len","total","startsWithDot","isFloat","word","esc","escStr","strct","node_t","node_loc_t","range","startNodeFrom","other","eat","canInsertSemicolon","semicolon","unexpected","expect","checkLVal","expr","loopLabel","kind","switchLabel","starttype","isBreak","parseIdent","lab","parseParenExpression","parseFor","init","parseVar","parseForIn","parseExpression","parseFunction","consequent","alternate","argument","discriminant","cases","sawDefault","isCase","block","parseBlock","handler","clause","param","guard","guardedHandlers","finalizer","maybeName","allowStrict","oldStrict","update","right","noIn","decl","noComma","parseMaybeAssign","expressions","parseExprOp","minPrec","prec","operator","op","parseMaybeUnary","exprNode","parseExprOps","parseMaybeConditional","parseSubscripts","parseExprAtom","base","noCalls","computed","callee","parseExprList","raw","tokStartLoc1","tokStart1","sawGetSet","parsePropertyName","isGetSet","conflict","parseObj","parseNew","isStatement","params","oldInFunc","oldLabels","close","allowTrailingComma","allowEmpty","elts","liberal","mod","strs"],"mappings":"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DA,EAAU,WAER,OADAwD,MAAMjJ,UAAU0K,KAAKnM,KAAKmC,KAAKoH,YACxBpH,MAETA,KAAK+G,2BAA2B/G,KAAK6B,MAAO,OAAQkD,GAEpD/E,KAAKI,WAAWiC,KAGd,kDACA,8CACA,kCACA,oEACA,YACA,wBACA,4BACA,yCACA,SACA,oBACA,+DACA,OACA,IACA,eACA,IACA,MAIA,mDACA,8CACA,+BACA,wFACA,wBACA,4BACA,gBACA,+DACA,kCACA,gBACA,kBACA,mDACA,IACA,IACA,cACA,IACA,MAIA,oDACA,8CACA,gCACA,kEACA,YACA,wBACA,4BACA,yCACA,SACA,oBACA,4CACA,OACA,IACA,IACA,MAIA,gDACA,8CACA,gCACA,8DACA,eACA,wBACA,4BACA,yCACA,sBACA,SACA,oBACA,mDACA,OACA,IACA,YACA,IACA,MAIA,mDACA,8CACA,0CACA,kEACA,4DACA,gCACA,wBACA,WACA,oCACA,kBACA,kEACA,IACA,kBACA,IACA,yBACA,mDACA,IACA,gBACA,IACA,MAIA,wDACA,8CACA,0CACA,yGACA,kEACA,+BACA,wBACA,WACA,mCACA,eACA,kEACA,IACA,kBACA,IACA,wBACA,mDACA,IACA,gBACA,IACA,MAIA,iDACA,8CACA,+BACA,6DACA,wBACA,4BACA,+DACA,kCACA,iDACA,eACA,IACA,IACA,gBACA,IACA,MAEA,gBACA,oCACA,8CAEA,wCACA,2BACA,IAEA,0CACA,mBACA,kDACA,4CACA,sBACA,yBACA,sBACA,aACA,IACA,IACA,uBACA,IACA,eACA,KACA,QAEA,2DACA,8CACA,eACA,gBACA,0CACA,wFACA,IACA,wBACA,IACA,MACA,IAQG,QAAQD,GACb,IASI2C,EATAjB,EAAkB9D,KAWtB+E,EAAU,SAASQ,GACjB,GAAIzB,EAAgB0B,gBAElB,IAAIyE,EAAmBjK,UAGnBiK,EAASnG,EAAgB4B,kBAAkB5B,EAAgBoG,WAG7D,GAAKvE,UAAUjF,QACjBoD,EAAgBoB,eAAepB,EAAgBgC,aAAc,6BAG/D,MAAMqE,EAAU,GACh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","file":"main.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import * as acorn from 'acorn';\nimport { Options } from 'acorn';\nimport * as ESTree from 'estree';\nimport { MyState } from './MyState';\nimport { MyDescriptor, MyValue, MyValueTable, NativeFunction, NodeConstructor } from './Types';\nimport { MyObject } from './MyObject';\n\n// Declare missing functions\ndeclare function escape(s: string): string;\n\ndeclare function unescape(s: string): string;\n\n/**\n * @license\n * JavaScript Interpreter\n *\n * Copyright 2013-2017 Google Inc. and Jun Kato\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Interpreting JavaScript in JavaScript.\n * @author fraser@google.com (Neil Fraser)\n * @author i@junkato.jp (Jun Kato)\n */\n\n/**\n * Create a new interpreter.\n * @param {string|!Object} code Raw JavaScript text or AST.\n * @param {Function=} opt_initFunc Optional initialization function.  Used to\n *     define APIs.  When called it is passed the interpreter object and the\n *     global scope object.\n * @constructor\n */\nexport class Interpreter {\n  private nodeConstructor: NodeConstructor;\n  public ast: ESTree.Program;\n  public global: MyObject;\n  public stateStack: MyState[];\n  public value: MyValue;\n  private initFunc_: (i: Interpreter, scope: MyObject) => void;\n  private paused_: boolean;\n  private polyfills_: string[];\n  private functionCounter_: number;\n  private stepFunctions_: { [key: string]: Function };\n\n  public OBJECT: MyObject;\n  public OBJECT_PROTO: MyObject;\n  public FUNCTION: MyObject;\n  public FUNCTION_PROTO: MyObject;\n  public ARRAY: MyObject;\n  public ARRAY_PROTO: MyObject;\n  public MAP: MyObject;\n  public MAP_PROTO: MyObject;\n  public SET: MyObject;\n  public SET_PROTO: MyObject;\n  public REGEXP: MyObject;\n  public REGEXP_PROTO: MyObject;\n\n  public ERROR: MyObject;\n  public EVAL_ERROR: MyObject;\n  public RANGE_ERROR: MyObject;\n  public REFERENCE_ERROR: MyObject;\n  public SYNTAX_ERROR: MyObject;\n  public TYPE_ERROR: MyObject;\n  public URI_ERROR: MyObject;\n\n  public STRING: MyObject;\n  public BOOLEAN: MyObject;\n  public NUMBER: MyObject;\n  public DATE: MyObject;\n\n  // The following properties are obsolete.  Do not use.\n  public UNDEFINED: MyObject;\n  public NULL: null;\n  public NAN: number;\n  public TRUE: boolean;\n  public FALSE: boolean;\n  public STRING_EMPTY: string;\n  public NUMBER_ZERO: number;\n  public NUMBER_ONE: number;\n\n  constructor(code: string | ESTree.Program, opt_initFunc?: (i: Interpreter, scope: MyObject) => void) {\n    if (typeof code === 'string') {\n      code = acorn.parse(code, Interpreter.PARSE_OPTIONS);\n    }\n    this.ast = code;\n    this.initFunc_ = opt_initFunc;\n    this.paused_ = false;\n    this.polyfills_ = [];\n    // Unique identifier for native functions.  Used in serialization.\n    this.functionCounter_ = 0;\n    // Map node types to our step function names; a property lookup is faster\n    // than string concatenation with \"step\" prefix.\n    this.stepFunctions_ = Object.create(null);\n    var stepMatch = /^step([A-Z]\\w*)$/;\n    var m;\n    var props = Object.getOwnPropertyNames(Interpreter.prototype);\n    for (var i = 0; i < props.length; i++) {\n      var methodName = props[i];\n      if (typeof Interpreter.prototype[methodName] === 'function' && (m = methodName.match(stepMatch))) {\n        this.stepFunctions_[m[1]] = (<Function>Interpreter.prototype[methodName]).bind(this);\n      }\n    }\n    // Create and initialize the global scope.\n    this.global = this.createScope(this.ast, null);\n    // Run the polyfills.\n    this.ast = acorn.parse(this.polyfills_.join('\\n'), Interpreter.PARSE_OPTIONS);\n    this.polyfills_ = undefined; // Allow polyfill strings to garbage collect.\n    this.stripLocations_(this.ast, undefined, undefined);\n    var state = new MyState(this.ast, this.global);\n    state.done = false;\n    this.stateStack = [state];\n    this.run();\n    this.value = undefined;\n    // Point at the main program.\n    this.ast = code;\n    var state = new MyState(this.ast, this.global);\n    state.done = false;\n    this.stateStack.length = 0;\n    this.stateStack[0] = state;\n    // Get a handle on Acorn's node_t object.  It's tricky to access.\n    this.nodeConstructor = <NodeConstructor>state.node.constructor;\n    // Preserve publicly properties from being pruned/renamed by JS compilers.\n    // Add others as needed.\n    this['stateStack'] = this.stateStack;\n    this['OBJECT'] = this.OBJECT;\n    this['OBJECT_PROTO'] = this.OBJECT_PROTO;\n    this['FUNCTION'] = this.FUNCTION;\n    this['FUNCTION_PROTO'] = this.FUNCTION_PROTO;\n    this['ARRAY'] = this.ARRAY;\n    this['ARRAY_PROTO'] = this.ARRAY_PROTO;\n    this['REGEXP'] = this.REGEXP;\n    this['REGEXP_PROTO'] = this.REGEXP_PROTO;\n    // The following properties are obsolete.  Do not use.\n    this['UNDEFINED'] = undefined;\n    this['NULL'] = null;\n    this['NAN'] = NaN;\n    this['TRUE'] = true;\n    this['FALSE'] = false;\n    this['STRING_EMPTY'] = '';\n    this['NUMBER_ZERO'] = 0;\n    this['NUMBER_ONE'] = 1;\n  }\n\n  /**\n   * @const {!Object} Configuration used for all Acorn parsing.\n   */\n  static PARSE_OPTIONS: Options = {\n    ecmaVersion: 6,\n  };\n\n  /**\n   * Property descriptor of readonly properties.\n   */\n  static READONLY_DESCRIPTOR: MyDescriptor = {\n    configurable: true,\n    enumerable: true,\n    writable: false,\n  };\n\n  /**\n   * Property descriptor of non-enumerable properties.\n   */\n  static NONENUMERABLE_DESCRIPTOR: MyDescriptor = {\n    configurable: true,\n    enumerable: false,\n    writable: true,\n  };\n\n  /**\n   * Property descriptor of readonly, non-enumerable properties.\n   */\n  static READONLY_NONENUMERABLE_DESCRIPTOR: MyDescriptor = {\n    configurable: true,\n    enumerable: false,\n    writable: false,\n  };\n\n  /**\n   * Property descriptor of variables.\n   */\n  static VARIABLE_DESCRIPTOR: MyDescriptor = {\n    configurable: false,\n    enumerable: true,\n    writable: true,\n  };\n\n  /**\n   * Unique symbol for indicating that a step has encountered an error, has\n   * added it to the stack, and will be thrown within the user's program.\n   * When STEP_ERROR is thrown in the JS-Interpreter, the error can be ignored.\n   */\n  static STEP_ERROR = {};\n\n  /**\n   * Unique symbol for indicating that a reference is a variable on the scope,\n   * not an object property.\n   */\n  static SCOPE_REFERENCE = {};\n\n  /**\n   * For cycle detection in array to string and error conversion;\n   * see spec bug github.com/tc39/ecma262/issues/289\n   * Since this is for atomic actions only, it can be a class property.\n   */\n  static toStringCycles_ = [];\n\n  /**\n   * Add more code to the interpreter.\n   * @param {string|!Object} code Raw JavaScript text or AST.\n   */\n  public appendCode(code: string | ESTree.Node) {\n    var state = this.stateStack[0];\n    if (!state || state.node['type'] !== 'Program') {\n      throw Error('Expecting original AST to start with a Program node.');\n    }\n    if (typeof code === 'string') {\n      code = acorn.parse(code, Interpreter.PARSE_OPTIONS);\n    }\n    if (!code || code['type'] !== 'Program') {\n      throw Error('Expecting new AST to start with a Program node.');\n    }\n    this.populateScope_(code, state.scope);\n    // Append the new program to the old one.\n    for (var i = 0, node; (node = code['body'][i]); i++) {\n      state.node['body'].push(node);\n    }\n    state.done = false;\n  }\n\n  /**\n   * Execute one step of the interpreter.\n   * @return {boolean} True if a step was executed, false if no more instructions.\n   */\n  public step(): boolean {\n    var stack = this.stateStack;\n    var state = stack[stack.length - 1];\n    if (!state) {\n      return false;\n    }\n    var node = state.node,\n      type = node['type'];\n    if (type === 'Program' && state.done) {\n      return false;\n    } else if (this.paused_) {\n      return true;\n    }\n    try {\n      var nextState = this.stepFunctions_[type](stack, state, node);\n    } catch (e) {\n      // Eat any step errors.  They have been thrown on the stack.\n      if (e !== Interpreter.STEP_ERROR) {\n        // Uh oh.  This is a real error in the JS-Interpreter.  Rethrow.\n        throw e;\n      }\n    }\n    if (nextState) {\n      stack.push(nextState);\n    }\n    if (!node['end']) {\n      // This is polyfill code.  Keep executing until we arrive at user code.\n      return this.step();\n    }\n    return true;\n  }\n\n  /**\n   * Execute the interpreter to program completion.  Vulnerable to infinite loops.\n   * @return {boolean} True if a execution is asynchronously blocked,\n   *     false if no more instructions.\n   */\n  public run() {\n    while (!this.paused_ && this.step()) {}\n    return this.paused_;\n  }\n\n  /**\n   * Initialize the global scope with buitin properties and functions.\n   * @param {!MyObject} scope Global scope.\n   */\n  public initGlobalScope(scope: MyObject) {\n    // Initialize uneditable global properties.\n    this.setProperty(scope, 'NaN', NaN, Interpreter.READONLY_DESCRIPTOR);\n    this.setProperty(scope, 'Infinity', Infinity, Interpreter.READONLY_DESCRIPTOR);\n    this.setProperty(scope, 'undefined', undefined, Interpreter.READONLY_DESCRIPTOR);\n    this.setProperty(scope, 'window', scope, Interpreter.READONLY_DESCRIPTOR);\n    this.setProperty(scope, 'this', scope, Interpreter.READONLY_DESCRIPTOR);\n    this.setProperty(scope, 'self', scope); // Editable.\n\n    // Create the objects which will become Object.prototype and\n    // Function.prototype, which are needed to bootstrap everything else.\n    this.OBJECT_PROTO = new MyObject(null);\n    this.FUNCTION_PROTO = new MyObject(this.OBJECT_PROTO);\n    // Initialize global objects.\n    this.initFunction(scope);\n    this.initObject(scope);\n    // Unable to set scope's parent prior (OBJECT did not exist).\n    // Note that in a browser this would be 'Window', whereas in Node.js it would\n    // be 'Object'.  This interpreter is closer to Node in that it has no DOM.\n    scope.proto = this.OBJECT_PROTO;\n    this.setProperty(scope, 'constructor', this.OBJECT);\n    this.initArray(scope);\n    this.initMap(scope);\n    this.initSet(scope);\n    this.initString(scope);\n    this.initBoolean(scope);\n    this.initNumber(scope);\n    this.initDate(scope);\n    this.initRegExp(scope);\n    this.initError(scope);\n    this.initMath(scope);\n    this.initJSON(scope);\n\n    // Initialize global functions.\n    var thisInterpreter = this;\n    var func = this.createNativeFunction(function(x) {\n      throw EvalError(\"Can't happen\");\n    }, false);\n    func.eval = true;\n    this.setProperty(scope, 'eval', func);\n\n    this.setProperty(scope, 'parseInt', this.createNativeFunction(parseInt, false));\n    this.setProperty(scope, 'parseFloat', this.createNativeFunction(parseFloat, false));\n\n    this.setProperty(scope, 'isNaN', this.createNativeFunction(isNaN, false));\n\n    this.setProperty(scope, 'isFinite', this.createNativeFunction(isFinite, false));\n\n    var strFunctions: any[] = [\n      [escape, 'escape'],\n      [unescape, 'unescape'],\n      [decodeURI, 'decodeURI'],\n      [decodeURIComponent, 'decodeURIComponent'],\n      [encodeURI, 'encodeURI'],\n      [encodeURIComponent, 'encodeURIComponent'],\n    ];\n    for (var i = 0; i < strFunctions.length; i++) {\n      var wrapper = (function(nativeFunc: (s: string) => string) {\n        return function(str) {\n          try {\n            return nativeFunc(str);\n          } catch (e) {\n            // decodeURI('%xy') will throw an error.  Catch and rethrow.\n            thisInterpreter.throwException(thisInterpreter.URI_ERROR, e.message);\n          }\n        };\n      })(strFunctions[i][0]);\n      this.setProperty(\n        scope,\n        strFunctions[i][1],\n        this.createNativeFunction(wrapper, false),\n        Interpreter.NONENUMERABLE_DESCRIPTOR\n      );\n    }\n\n    // Run any user-provided initialization.\n    if (this.initFunc_) {\n      this.initFunc_(this, scope);\n    }\n  }\n\n  /**\n   * Initialize the Function class.\n   * @param {!MyObject} scope Global scope.\n   */\n  public initFunction(scope: MyObject) {\n    var thisInterpreter = this;\n    var wrapper;\n    var identifierRegexp = /^[A-Za-z_$][\\w$]*$/;\n    // Function constructor.\n    wrapper = function(var_args) {\n      if (thisInterpreter.calledWithNew()) {\n        // Called as new Function().\n        var newFunc = <MyObject>this;\n      } else {\n        // Called as Function().\n        var newFunc = thisInterpreter.createObjectProto(thisInterpreter.FUNCTION_PROTO);\n      }\n      if (arguments.length) {\n        var code = String(arguments[arguments.length - 1]);\n      } else {\n        var code = '';\n      }\n      var args: string[] | string = [];\n      for (var i = 0; i < arguments.length - 1; i++) {\n        var name = String(arguments[i]);\n        if (!name.match(identifierRegexp)) {\n          thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR, 'Invalid function argument: ' + name);\n        }\n        args.push(name);\n      }\n      args = args.join(', ');\n      // Interestingly, the scope for constructed functions is the global scope,\n      // even if they were constructed in some other scope.\n      newFunc.parentScope = thisInterpreter.global;\n      // Acorn needs to parse code in the context of a function or else 'return'\n      // statements will be syntax errors.\n      try {\n        var ast = acorn.parse('$ = function(' + args + ') {' + code + '};', Interpreter.PARSE_OPTIONS);\n      } catch (e) {\n        // Acorn threw a SyntaxError.  Rethrow as a trappable error.\n        thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR, 'Invalid code: ' + e.message);\n      }\n      if (ast['body'].length !== 1) {\n        // Function('a', 'return a + 6;}; {alert(1);');\n        thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR, 'Invalid code in function body.');\n      }\n      newFunc.node = ast['body'][0]['expression']['right'];\n      thisInterpreter.setProperty(newFunc, 'length', newFunc.node['length'], Interpreter.READONLY_DESCRIPTOR);\n      return newFunc;\n    };\n    wrapper.id = this.functionCounter_++;\n    this.FUNCTION = this.createObjectProto(this.FUNCTION_PROTO);\n\n    this.setProperty(scope, 'Function', this.FUNCTION);\n    // Manually setup type and prototype because createObj doesn't recognize\n    // this object as a function (this.FUNCTION did not exist).\n    this.setProperty(this.FUNCTION, 'prototype', this.FUNCTION_PROTO);\n    this.FUNCTION.nativeFunc = wrapper;\n\n    // Configure Function.prototype.\n    this.setProperty(this.FUNCTION_PROTO, 'constructor', this.FUNCTION, Interpreter.NONENUMERABLE_DESCRIPTOR);\n    this.FUNCTION_PROTO.nativeFunc = function() {};\n    this.FUNCTION_PROTO.nativeFunc.id = this.functionCounter_++;\n    this.setProperty(this.FUNCTION_PROTO, 'length', 0, Interpreter.READONLY_DESCRIPTOR);\n\n    var boxThis = function(value) {\n      // In non-strict mode 'this' must be an object.\n      if ((!value || !value.isObject) && !thisInterpreter.getScope().strict) {\n        if (value === undefined || value === null) {\n          // 'Undefined' and 'null' are changed to global object.\n          value = thisInterpreter.global;\n        } else {\n          // Primitives must be boxed in non-strict mode.\n          var box = thisInterpreter.createObjectProto(thisInterpreter.getPrototype(value));\n          box.data = value;\n          value = box;\n        }\n      }\n      return value;\n    };\n\n    wrapper = function(thisArg, args) {\n      var state = thisInterpreter.stateStack[thisInterpreter.stateStack.length - 1];\n      // Rewrite the current 'CallExpression' to apply a different function.\n      state.func_ = this;\n      // Assign the 'this' object.\n      state.funcThis_ = boxThis(thisArg);\n      // Bind any provided arguments.\n      state.arguments_ = [];\n      if (args !== null && args !== undefined) {\n        if (args.isObject) {\n          state.arguments_ = thisInterpreter.pseudoToNative(args);\n        } else {\n          thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, 'CreateListFromArrayLike called on non-object');\n        }\n      }\n      state.doneExec_ = false;\n    };\n    this.setNativeFunctionPrototype(this.FUNCTION, 'apply', wrapper);\n\n    wrapper = function(thisArg, var_args) {\n      var state = thisInterpreter.stateStack[thisInterpreter.stateStack.length - 1];\n      // Rewrite the current 'CallExpression' to call a different function.\n      state.func_ = this;\n      // Assign the 'this' object.\n      state.funcThis_ = boxThis(thisArg);\n      // Bind any provided arguments.\n      state.arguments_ = [];\n      for (var i = 1; i < arguments.length; i++) {\n        state.arguments_.push(arguments[i]);\n      }\n      state.doneExec_ = false;\n    };\n    this.setNativeFunctionPrototype(this.FUNCTION, 'call', wrapper);\n\n    this.polyfills_.push(\n      // Polyfill copied from:\n      // developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind\n      \"Object.defineProperty(Function.prototype, 'bind',\",\n      '{configurable: true, writable: true, value:',\n      'function(oThis) {',\n      \"if (typeof this !== 'function') {\",\n      \"throw TypeError('What is trying to be bound is not callable');\",\n      '}',\n      'var aArgs   = Array.prototype.slice.call(arguments, 1),',\n      'fToBind = this,',\n      'fNOP    = function() {},',\n      'fBound  = function() {',\n      'return fToBind.apply(this instanceof fNOP',\n      '? this',\n      ': oThis,',\n      'aArgs.concat(Array.prototype.slice.call(arguments)));',\n      '};',\n      'if (this.prototype) {',\n      'fNOP.prototype = this.prototype;',\n      '}',\n      'fBound.prototype = new fNOP();',\n      'return fBound;',\n      '}',\n      '});',\n      ''\n    );\n\n    // Function has no parent to inherit from, so it needs its own mandatory\n    // toString and valueOf functions.\n    wrapper = function() {\n      return this.toString();\n    };\n    this.setNativeFunctionPrototype(this.FUNCTION, 'toString', wrapper);\n    this.setProperty(\n      this.FUNCTION,\n      'toString',\n      this.createNativeFunction(wrapper, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR\n    );\n    wrapper = function() {\n      return this.valueOf();\n    };\n    this.setNativeFunctionPrototype(this.FUNCTION, 'valueOf', wrapper);\n    this.setProperty(\n      this.FUNCTION,\n      'valueOf',\n      this.createNativeFunction(wrapper, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR\n    );\n  }\n\n  /**\n   * Initialize the Object class.\n   * @param {!MyObject} scope Global scope.\n   */\n  public initObject(scope: MyObject) {\n    var thisInterpreter = this;\n    var wrapper;\n    // Object constructor.\n    wrapper = function(value) {\n      if (value === undefined || value === null) {\n        // Create a new object.\n        if (thisInterpreter.calledWithNew()) {\n          // Called as new Object().\n          return this;\n        } else {\n          // Called as Object().\n          return thisInterpreter.createObjectProto(thisInterpreter.OBJECT_PROTO);\n        }\n      }\n      if (!value.isObject) {\n        // Wrap the value as an object.\n        var box = thisInterpreter.createObjectProto(thisInterpreter.getPrototype(value));\n        box.data = value;\n        return box;\n      }\n      // Return the provided object.\n      return value;\n    };\n    this.OBJECT = this.createNativeFunction(wrapper, true);\n    // Throw away the created prototype and use the root prototype.\n    this.setProperty(this.OBJECT, 'prototype', this.OBJECT_PROTO);\n    this.setProperty(this.OBJECT_PROTO, 'constructor', this.OBJECT);\n    this.setProperty(scope, 'Object', this.OBJECT);\n\n    /**\n     * Checks if the provided value is null or undefined.\n     * If so, then throw an error in the call stack.\n     * @param {MyValue} value Value to check.\n     */\n    var throwIfNullUndefined = function(value) {\n      if (value === undefined || value === null) {\n        thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, \"Cannot convert '\" + value + \"' to object\");\n      }\n    };\n\n    // Static methods on Object.\n    wrapper = function(obj) {\n      throwIfNullUndefined(obj);\n      var props = obj.isObject ? obj.properties : obj;\n      return thisInterpreter.nativeToPseudo(Object.getOwnPropertyNames(props));\n    };\n    this.setProperty(\n      this.OBJECT,\n      'getOwnPropertyNames',\n      this.createNativeFunction(wrapper, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR\n    );\n\n    wrapper = function(obj) {\n      throwIfNullUndefined(obj);\n      if (!obj.isObject) {\n        return thisInterpreter.nativeToPseudo(Object.keys(obj));\n      }\n      return thisInterpreter.nativeToPseudo(Object.keys(obj.properties));\n    };\n    this.setProperty(\n      this.OBJECT,\n      'keys',\n      this.createNativeFunction(wrapper, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR\n    );\n\n    wrapper = function(proto) {\n      // Support for the second argument is the responsibility of a polyfill.\n      if (proto === null) {\n        return thisInterpreter.createObjectProto(null);\n      }\n      if (proto === undefined || !proto.isObject) {\n        thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, 'Object prototype may only be an Object or null');\n      }\n      return thisInterpreter.createObjectProto(proto);\n    };\n    this.setProperty(\n      this.OBJECT,\n      'create',\n      this.createNativeFunction(wrapper, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR\n    );\n\n    // Add a polyfill to handle create's second argument.\n    this.polyfills_.push(\n      '(function() {',\n      'var create_ = Object.create;',\n      'Object.create = function(proto, props) {',\n      'var obj = create_(proto);',\n      'props && Object.defineProperties(obj, props);',\n      'return obj;',\n      '};',\n      '})();',\n      ''\n    );\n\n    wrapper = function(obj, prop, descriptor) {\n      prop = String(prop);\n      if (!obj || !obj.isObject) {\n        thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, 'Object.defineProperty called on non-object');\n      }\n      if (!descriptor || !descriptor.isObject) {\n        thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, 'Property description must be an object');\n      }\n      if (!obj.properties[prop] && obj.preventExtensions) {\n        thisInterpreter.throwException(\n          thisInterpreter.TYPE_ERROR,\n          \"Can't define property '\" + prop + \"', object is not extensible\"\n        );\n      }\n      // The polyfill guarantees no inheritance and no getter functions.\n      // Therefore the descriptor properties map is the native object needed.\n      thisInterpreter.setProperty(obj, prop, ReferenceError, descriptor.properties);\n      return obj;\n    };\n    this.setProperty(\n      this.OBJECT,\n      'defineProperty',\n      this.createNativeFunction(wrapper, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR\n    );\n\n    this.polyfills_.push(\n      // Flatten the descriptor to remove any inheritance or getter functions.\n      '(function() {',\n      'var defineProperty_ = Object.defineProperty;',\n      'Object.defineProperty = function(obj, prop, d1) {',\n      'var d2 = {};',\n      \"if ('configurable' in d1) d2.configurable = d1.configurable;\",\n      \"if ('enumerable' in d1) d2.enumerable = d1.enumerable;\",\n      \"if ('writable' in d1) d2.writable = d1.writable;\",\n      \"if ('value' in d1) d2.value = d1.value;\",\n      \"if ('get' in d1) d2.get = d1.get;\",\n      \"if ('set' in d1) d2.set = d1.set;\",\n      'return defineProperty_(obj, prop, d2);',\n      '};',\n      '})();',\n\n      \"Object.defineProperty(Object, 'defineProperties',\",\n      '{configurable: true, writable: true, value:',\n      'function(obj, props) {',\n      'var keys = Object.keys(props);',\n      'for (var i = 0; i < keys.length; i++) {',\n      'Object.defineProperty(obj, keys[i], props[keys[i]]);',\n      '}',\n      'return obj;',\n      '}',\n      '});',\n      ''\n    );\n\n    wrapper = function(obj, prop) {\n      if (!obj || !obj.isObject) {\n        thisInterpreter.throwException(\n          thisInterpreter.TYPE_ERROR,\n          'Object.getOwnPropertyDescriptor called on non-object'\n        );\n      }\n      prop = String(prop);\n      if (!(prop in obj.properties)) {\n        return undefined;\n      }\n      var descriptor = Object.getOwnPropertyDescriptor(obj.properties, prop);\n      var getter = obj.getter[prop];\n      var setter = obj.setter[prop];\n\n      if (getter || setter) {\n        descriptor.get = getter;\n        descriptor.set = setter;\n        delete descriptor.value;\n        delete descriptor.writable;\n      }\n      var pseudoDescriptor = <MyObject>thisInterpreter.nativeToPseudo(descriptor);\n      if ('value' in descriptor) {\n        thisInterpreter.setProperty(pseudoDescriptor, 'value', descriptor.value);\n      }\n      return pseudoDescriptor;\n    };\n    this.setProperty(\n      this.OBJECT,\n      'getOwnPropertyDescriptor',\n      this.createNativeFunction(wrapper, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR\n    );\n\n    wrapper = function(obj) {\n      throwIfNullUndefined(obj);\n      return thisInterpreter.getPrototype(obj);\n    };\n    this.setProperty(\n      this.OBJECT,\n      'getPrototypeOf',\n      this.createNativeFunction(wrapper, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR\n    );\n\n    wrapper = function(obj) {\n      return Boolean(obj) && !obj.preventExtensions;\n    };\n    this.setProperty(\n      this.OBJECT,\n      'isExtensible',\n      this.createNativeFunction(wrapper, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR\n    );\n\n    wrapper = function(obj) {\n      if (obj && obj.isObject) {\n        obj.preventExtensions = true;\n      }\n      return obj;\n    };\n    this.setProperty(\n      this.OBJECT,\n      'preventExtensions',\n      this.createNativeFunction(wrapper, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR\n    );\n\n    // Instance methods on Object.\n    this.setNativeFunctionPrototype(this.OBJECT, 'toString', MyObject.prototype.toString);\n    this.setNativeFunctionPrototype(this.OBJECT, 'toLocaleString', MyObject.prototype.toString);\n    this.setNativeFunctionPrototype(this.OBJECT, 'valueOf', MyObject.prototype.valueOf);\n\n    wrapper = function(prop) {\n      throwIfNullUndefined(this);\n      if (!this.isObject) {\n        return this.hasOwnProperty(prop);\n      }\n      return String(prop) in this.properties;\n    };\n    this.setNativeFunctionPrototype(this.OBJECT, 'hasOwnProperty', wrapper);\n\n    wrapper = function(prop) {\n      throwIfNullUndefined(this);\n      return Object.prototype.propertyIsEnumerable.call(this.properties, prop);\n    };\n    this.setNativeFunctionPrototype(this.OBJECT, 'propertyIsEnumerable', wrapper);\n\n    wrapper = function(obj) {\n      while (true) {\n        // Note, circular loops shouldn't be possible.\n        obj = thisInterpreter.getPrototype(obj);\n        if (!obj) {\n          // No parent; reached the top.\n          return false;\n        }\n        if (obj === this) {\n          return true;\n        }\n      }\n    };\n    this.setNativeFunctionPrototype(this.OBJECT, 'isPrototypeOf', wrapper);\n  }\n\n  /**\n   * Initialize the Array class.\n   * @param {!MyObject} scope Global scope.\n   */\n  public initArray(scope: MyObject) {\n    var thisInterpreter = this;\n    var getInt = function(obj, def) {\n      // Return an integer, or the default.\n      var n = obj ? Math.floor(obj) : def;\n      if (isNaN(n)) {\n        n = def;\n      }\n      return n;\n    };\n    var wrapper;\n    // Array constructor.\n    wrapper = function(var_args) {\n      if (thisInterpreter.calledWithNew()) {\n        // Called as new Array().\n        var newArray = <MyObject>this;\n      } else {\n        // Called as Array().\n        var newArray = thisInterpreter.createObjectProto(thisInterpreter.ARRAY_PROTO);\n      }\n      var first = arguments[0];\n      if (arguments.length === 1 && typeof first === 'number') {\n        if (isNaN(Interpreter.legalArrayLength(first))) {\n          thisInterpreter.throwException(thisInterpreter.RANGE_ERROR, 'Invalid array length');\n        }\n        newArray.properties.length = first;\n      } else {\n        for (var i = 0; i < arguments.length; i++) {\n          newArray.properties[i] = arguments[i];\n        }\n        newArray.properties.length = i;\n      }\n      return newArray;\n    };\n    this.ARRAY = this.createNativeFunction(wrapper, true);\n    this.ARRAY_PROTO = this.ARRAY.properties['prototype'];\n    this.setProperty(scope, 'Array', this.ARRAY);\n\n    // Static methods on Array.\n    wrapper = function(obj) {\n      return obj && obj.class === 'Array';\n    };\n    this.setProperty(\n      this.ARRAY,\n      'isArray',\n      this.createNativeFunction(wrapper, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR\n    );\n\n    // Instance methods on Array.\n    wrapper = function() {\n      return Array.prototype.pop.call(this.properties);\n    };\n    this.setNativeFunctionPrototype(this.ARRAY, 'pop', wrapper);\n\n    wrapper = function(var_args) {\n      return Array.prototype.push.apply(this.properties, arguments);\n    };\n    this.setNativeFunctionPrototype(this.ARRAY, 'push', wrapper);\n\n    wrapper = function() {\n      return Array.prototype.shift.call(this.properties);\n    };\n    this.setNativeFunctionPrototype(this.ARRAY, 'shift', wrapper);\n\n    wrapper = function(var_args) {\n      return Array.prototype.unshift.apply(this.properties, arguments);\n    };\n    this.setNativeFunctionPrototype(this.ARRAY, 'unshift', wrapper);\n\n    wrapper = function() {\n      Array.prototype.reverse.call(this.properties);\n      return this;\n    };\n    this.setNativeFunctionPrototype(this.ARRAY, 'reverse', wrapper);\n\n    wrapper = function(index, howmany /*, var_args*/) {\n      var list = Array.prototype.splice.apply(this.properties, arguments);\n      return thisInterpreter.nativeToPseudo(list);\n    };\n    this.setNativeFunctionPrototype(this.ARRAY, 'splice', wrapper);\n\n    wrapper = function(opt_begin, opt_end) {\n      var list = Array.prototype.slice.call(this.properties, opt_begin, opt_end);\n      return thisInterpreter.nativeToPseudo(list);\n    };\n    this.setNativeFunctionPrototype(this.ARRAY, 'slice', wrapper);\n\n    wrapper = function(opt_separator) {\n      return Array.prototype.join.call(this.properties, opt_separator);\n    };\n    this.setNativeFunctionPrototype(this.ARRAY, 'join', wrapper);\n\n    wrapper = function(var_args) {\n      var list = [];\n      var length = 0;\n      // Start by copying the current array.\n      var iLength = thisInterpreter.getProperty(this, 'length');\n      for (var i = 0; i < iLength; i++) {\n        if (thisInterpreter.hasProperty(this, i)) {\n          var element = thisInterpreter.getProperty(this, i);\n          list[length] = element;\n        }\n        length++;\n      }\n      // Loop through all arguments and copy them in.\n      for (var i = 0; i < arguments.length; i++) {\n        var value = arguments[i];\n        if (thisInterpreter.isa(value, thisInterpreter.ARRAY)) {\n          var jLength = thisInterpreter.getProperty(value, 'length');\n          for (var j = 0; j < jLength; j++) {\n            if (thisInterpreter.hasProperty(value, j)) {\n              list[length] = thisInterpreter.getProperty(value, j);\n            }\n            length++;\n          }\n        } else {\n          list[length] = value;\n        }\n      }\n      return thisInterpreter.nativeToPseudo(list);\n    };\n    this.setNativeFunctionPrototype(this.ARRAY, 'concat', wrapper);\n\n    wrapper = function(searchElement, opt_fromIndex) {\n      return Array.prototype.indexOf.apply(this.properties, arguments);\n    };\n    this.setNativeFunctionPrototype(this.ARRAY, 'indexOf', wrapper);\n\n    wrapper = function(searchElement, opt_fromIndex) {\n      return Array.prototype.lastIndexOf.apply(this.properties, arguments);\n    };\n    this.setNativeFunctionPrototype(this.ARRAY, 'lastIndexOf', wrapper);\n\n    wrapper = function() {\n      Array.prototype.sort.call(this.properties);\n      return this;\n    };\n    this.setNativeFunctionPrototype(this.ARRAY, 'sort', wrapper);\n\n    this.polyfills_.push(\n      // Polyfill copied from:\n      // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/every\n      \"Object.defineProperty(Array.prototype, 'every',\",\n      '{configurable: true, writable: true, value:',\n      'function(callbackfn, thisArg) {',\n      \"if (!this || typeof callbackfn !== 'function') throw TypeError();\",\n      'var T, k;',\n      'var O = Object(this);',\n      'var len = O.length >>> 0;',\n      'if (arguments.length > 1) T = thisArg;',\n      'k = 0;',\n      'while (k < len) {',\n      'if (k in O && !callbackfn.call(T, O[k], k, O)) return false;',\n      'k++;',\n      '}',\n      'return true;',\n      '}',\n      '});',\n\n      // Polyfill copied from:\n      // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\n      \"Object.defineProperty(Array.prototype, 'filter',\",\n      '{configurable: true, writable: true, value:',\n      'function(fun/*, thisArg*/) {',\n      \"if (this === void 0 || this === null || typeof fun !== 'function') throw TypeError();\",\n      'var t = Object(this);',\n      'var len = t.length >>> 0;',\n      'var res = [];',\n      'var thisArg = arguments.length >= 2 ? arguments[1] : void 0;',\n      'for (var i = 0; i < len; i++) {',\n      'if (i in t) {',\n      'var val = t[i];',\n      'if (fun.call(thisArg, val, i, t)) res.push(val);',\n      '}',\n      '}',\n      'return res;',\n      '}',\n      '});',\n\n      // Polyfill copied from:\n      // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\n      \"Object.defineProperty(Array.prototype, 'forEach',\",\n      '{configurable: true, writable: true, value:',\n      'function(callback, thisArg) {',\n      \"if (!this || typeof callback !== 'function') throw TypeError();\",\n      'var T, k;',\n      'var O = Object(this);',\n      'var len = O.length >>> 0;',\n      'if (arguments.length > 1) T = thisArg;',\n      'k = 0;',\n      'while (k < len) {',\n      'if (k in O) callback.call(T, O[k], k, O);',\n      'k++;',\n      '}',\n      '}',\n      '});',\n\n      // Polyfill copied from:\n      // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/map\n      \"Object.defineProperty(Array.prototype, 'map',\",\n      '{configurable: true, writable: true, value:',\n      'function(callback, thisArg) {',\n      \"if (!this || typeof callback !== 'function') new TypeError;\",\n      'var T, A, k;',\n      'var O = Object(this);',\n      'var len = O.length >>> 0;',\n      'if (arguments.length > 1) T = thisArg;',\n      'A = new Array(len);',\n      'k = 0;',\n      'while (k < len) {',\n      'if (k in O) A[k] = callback.call(T, O[k], k, O);',\n      'k++;',\n      '}',\n      'return A;',\n      '}',\n      '});',\n\n      // Polyfill copied from:\n      // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\n      \"Object.defineProperty(Array.prototype, 'reduce',\",\n      '{configurable: true, writable: true, value:',\n      'function(callback /*, initialValue*/) {',\n      \"if (!this || typeof callback !== 'function') throw TypeError();\",\n      'var t = Object(this), len = t.length >>> 0, k = 0, value;',\n      'if (arguments.length === 2) {',\n      'value = arguments[1];',\n      '} else {',\n      'while (k < len && !(k in t)) k++;',\n      'if (k >= len) {',\n      \"throw TypeError('Reduce of empty array with no initial value');\",\n      '}',\n      'value = t[k++];',\n      '}',\n      'for (; k < len; k++) {',\n      'if (k in t) value = callback(value, t[k], k, t);',\n      '}',\n      'return value;',\n      '}',\n      '});',\n\n      // Polyfill copied from:\n      // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight\n      \"Object.defineProperty(Array.prototype, 'reduceRight',\",\n      '{configurable: true, writable: true, value:',\n      'function(callback /*, initialValue*/) {',\n      \"if (null === this || 'undefined' === typeof this || 'function' !== typeof callback) throw TypeError();\",\n      'var t = Object(this), len = t.length >>> 0, k = len - 1, value;',\n      'if (arguments.length >= 2) {',\n      'value = arguments[1];',\n      '} else {',\n      'while (k >= 0 && !(k in t)) k--;',\n      'if (k < 0) {',\n      \"throw TypeError('Reduce of empty array with no initial value');\",\n      '}',\n      'value = t[k--];',\n      '}',\n      'for (; k >= 0; k--) {',\n      'if (k in t) value = callback(value, t[k], k, t);',\n      '}',\n      'return value;',\n      '}',\n      '});',\n\n      // Polyfill copied from:\n      // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/some\n      \"Object.defineProperty(Array.prototype, 'some',\",\n      '{configurable: true, writable: true, value:',\n      'function(fun/*, thisArg*/) {',\n      \"if (!this || typeof fun !== 'function') throw TypeError();\",\n      'var t = Object(this);',\n      'var len = t.length >>> 0;',\n      'var thisArg = arguments.length >= 2 ? arguments[1] : void 0;',\n      'for (var i = 0; i < len; i++) {',\n      'if (i in t && fun.call(thisArg, t[i], i, t)) {',\n      'return true;',\n      '}',\n      '}',\n      'return false;',\n      '}',\n      '});',\n\n      '(function() {',\n      'var sort_ = Array.prototype.sort;',\n      'Array.prototype.sort = function(opt_comp) {',\n      // Fast native sort.\n      \"if (typeof opt_comp !== 'function') {\",\n      'return sort_.call(this);',\n      '}',\n      // Slow bubble sort.\n      'for (var i = 0; i < this.length; i++) {',\n      'var changes = 0;',\n      'for (var j = 0; j < this.length - i - 1; j++) {',\n      'if (opt_comp(this[j], this[j + 1]) > 0) {',\n      'var swap = this[j];',\n      'this[j] = this[j + 1];',\n      'this[j + 1] = swap;',\n      'changes++;',\n      '}',\n      '}',\n      'if (!changes) break;',\n      '}',\n      'return this;',\n      '};',\n      '})();',\n\n      \"Object.defineProperty(Array.prototype, 'toLocaleString',\",\n      '{configurable: true, writable: true, value:',\n      'function() {',\n      'var out = [];',\n      'for (var i = 0; i < this.length; i++) {',\n      \"out[i] = (this[i] === null || this[i] === undefined) ? '' : this[i].toLocaleString();\",\n      '}',\n      \"return out.join(',');\",\n      '}',\n      '});',\n      ''\n    );\n  }\n\n  /**\n   * Initialize the Map class.\n   * @param {!MyObject} scope Global scope.\n   */\n  public initMap(scope: MyObject) {\n    var thisInterpreter = this;\n    var getInt = function(obj, def) {\n      // Return an integer, or the default.\n      var n = obj ? Math.floor(obj) : def;\n      if (isNaN(n)) {\n        n = def;\n      }\n      return n;\n    };\n    var wrapper;\n    // Map constructor.\n    wrapper = function(var_args) {\n      if (thisInterpreter.calledWithNew()) {\n        // Called as new Map().\n        var newMap = <MyObject>this;\n      } else {\n        // Called as Map().\n        var newMap = thisInterpreter.createObjectProto(thisInterpreter.MAP_PROTO);\n      }\n\n      if (2 <= arguments.length) {\n        thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR, 'Invalid arguments for Map');\n      }\n\n      const entries = [];\n      if (arguments.length === 1) {\n        const first = arguments[0];\n        if (first instanceof MyObject && first.class === 'Array') {\n          for (const pair of arguments[0].properties) {\n            const key = pair.properties[0];\n            const value = pair.properties[1];\n            entries.push({ key, value });\n          }\n        }\n      }\n      newMap.properties['[[Entries]]'] = entries;\n      newMap.properties.size = entries.length;\n      return newMap;\n    };\n    this.MAP = this.createNativeFunction(wrapper, true);\n    this.MAP_PROTO = this.MAP.properties['prototype'];\n    this.setProperty(scope, 'Map', this.MAP);\n\n    // No Static methods on Map.\n\n    // Instance methods on Map.\n    wrapper = function() {\n      this.properties['[[Entries]]'] = [];\n      this.properties.size = 0;\n      return undefined;\n    };\n    this.setNativeFunctionPrototype(this.MAP, 'clear', wrapper);\n\n    wrapper = function(keyToDelete) {\n      let i = 0;\n      for (const obj of this.properties['[[Entries]]']) {\n        if (obj.key === keyToDelete) {\n          this.properties['[[Entries]]'].splice(i, 1);\n          this.properties.size = this.properties['[[Entries]]'].length;\n          return true;\n        }\n        ++i;\n      }\n      return false;\n    };\n    this.setNativeFunctionPrototype(this.MAP, 'delete', wrapper);\n\n    wrapper = function(keyToFind) {\n      for (const obj of this.properties['[[Entries]]']) {\n        if (obj.key === keyToFind) {\n          return obj.value;\n        }\n      }\n      return undefined;\n    };\n    this.setNativeFunctionPrototype(this.MAP, 'get', wrapper);\n\n    wrapper = function(key) {\n      for (const obj of this.properties['[[Entries]]']) {\n        if (obj.key === key) {\n          return true;\n        }\n      }\n      return false;\n    };\n    this.setNativeFunctionPrototype(this.MAP, 'has', wrapper);\n\n    wrapper = function(key, value) {\n      this.properties['[[Entries]]'].push({ key, value });\n      this.properties.size = this.properties['[[Entries]]'].length;\n      return this;\n    };\n    this.setNativeFunctionPrototype(this.MAP, 'set', wrapper);\n\n    wrapper = function() {\n      const entries = this.properties['[[Entries]]'];\n      return new Map(entries.map(kv => [kv.key, kv.value]))[Symbol.iterator]();\n    };\n    this.setNativeFunctionPrototype(this.MAP, 'entries', wrapper);\n\n    wrapper = function() {\n      const entries = this.properties['[[Entries]]'];\n      return new Map(entries.map(kv => kv.key))[Symbol.iterator]();\n    };\n    this.setNativeFunctionPrototype(this.MAP, 'keys', wrapper);\n\n    wrapper = function() {\n      const entries = this.properties['[[Entries]]'];\n      return new Map(entries.map(kv => kv.value))[Symbol.iterator]();\n    };\n    this.setNativeFunctionPrototype(this.MAP, 'values', wrapper);\n\n    this.polyfills_.push(\n      \"Object.defineProperty(Map.prototype, 'forEach',\",\n      '{configurable: true, writable: true, value:',\n      'function(callback, thisArg) {',\n      \"if (!this || typeof callback !== 'function') throw TypeError();\",\n      'var T, i;',\n      \"var O = Object(this['[[Entries]]']);\",\n      'var len = O.size >>> 0;',\n      'if (arguments.length > 1) T = thisArg;',\n      'i = 0;',\n      'while (i < len) {',\n      'if (i in O) callback.call(T, O.value, O.key, O);',\n      'i++;',\n      '}',\n      '}',\n      '});'\n    );\n  }\n\n  /**\n   * Initialize the Set class.\n   * @param {!MyObject} scope Global scope.\n   */\n  public initSet(scope: MyObject) {\n    var thisInterpreter = this;\n    var getInt = function(obj, def) {\n      // Return an integer, or the default.\n      var n = obj ? Math.floor(obj) : def;\n      if (isNaN(n)) {\n        n = def;\n      }\n      return n;\n    };\n    var wrapper;\n    // Set constructor.\n    wrapper = function(var_args) {\n      if (thisInterpreter.calledWithNew()) {\n        // Called as new Set().\n        var newSet = <MyObject>this;\n      } else {\n        // Called as Set().\n        var newSet = thisInterpreter.createObjectProto(thisInterpreter.SET_PROTO);\n      }\n\n      if (2 <= arguments.length) {\n        thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR, 'Invalid arguments for Set');\n      }\n\n      const entries = [];\n      if (arguments.length === 1) {\n        const first = arguments[0];\n        if (first instanceof MyObject && first.class === 'Array') {\n          for (const value of arguments[0].properties) {\n            entries.push({ value });\n          }\n        }\n      }\n      newSet.properties['[[Entries]]'] = entries;\n      newSet.properties['size'] = entries.length;\n      return newSet;\n    };\n    this.SET = this.createNativeFunction(wrapper, true);\n    this.SET_PROTO = this.SET.properties['prototype'];\n    this.setProperty(scope, 'Set', this.SET);\n\n    // No Static methods on Set.\n\n    // Instance methods on Set.\n    wrapper = function() {\n      this.properties['[[Entries]]'] = [];\n      this.properties.size = 0;\n      return undefined;\n    };\n    this.setNativeFunctionPrototype(this.SET, 'clear', wrapper);\n\n    wrapper = function(valueToDelete) {\n      let i = 0;\n      for (const v of this.properties['[[Entries]]']) {\n        if (v === valueToDelete) {\n          this.properties['[[Entries]]'].splice(i, 1);\n          this.properties.size = this.properties['[[Entries]]'].length;\n          return true;\n        }\n        ++i;\n      }\n      return false;\n    };\n    this.setNativeFunctionPrototype(this.SET, 'delete', wrapper);\n\n    wrapper = function(value) {\n      this.properties['[[Entries]]'].push({ value });\n      this.properties.size = this.properties['[[Entries]]'].length;\n      return this;\n    };\n    this.setNativeFunctionPrototype(this.SET, 'add', wrapper);\n\n    wrapper = function(value) {\n      for (const v of this.properties['[[Entries]]']) {\n        if (v === value) {\n          return true;\n        }\n      }\n      return false;\n    };\n    this.setNativeFunctionPrototype(this.SET, 'has', wrapper);\n\n    wrapper = function() {\n      const entries = this.properties['[[Entries]]'];\n      return new Map(entries.map(kv => [kv.value, kv.value]))[Symbol.iterator]();\n    };\n    this.setNativeFunctionPrototype(this.SET, 'entries', wrapper);\n\n    wrapper = function() {\n      const entries = this.properties['[[Entries]]'];\n      return entries.map(kv => kv.value)[Symbol.iterator]();\n    };\n    this.setNativeFunctionPrototype(this.SET, 'keys', wrapper);\n\n    wrapper = function() {\n      const entries = this.properties['[[Entries]]'];\n      return entries.map(kv => kv.value)[Symbol.iterator]();\n    };\n    this.setNativeFunctionPrototype(this.SET, 'values', wrapper);\n\n    this.polyfills_.push(\n      \"Object.defineProperty(Map.prototype, 'forEach',\",\n      '{configurable: true, writable: true, value:',\n      'function(callback, thisArg) {',\n      \"if (!this || typeof callback !== 'function') throw TypeError();\",\n      'var T, i;',\n      \"var O = Object(this['[[Entries]]']);\",\n      'var len = O.size >>> 0;',\n      'if (arguments.length > 1) T = thisArg;',\n      'i = 0;',\n      'while (i < len) {',\n      'if (i in O) callback.call(T, O.value, O.key, O);',\n      'i++;',\n      '}',\n      '}',\n      '});'\n    );\n  }\n\n  /**\n   * Initialize the String class.\n   * @param {!MyObject} scope Global scope.\n   */\n  public initString(scope: MyObject) {\n    var thisInterpreter = this;\n    var wrapper;\n    // String constructor.\n    wrapper = function(value) {\n      value = String(value);\n      if (thisInterpreter.calledWithNew()) {\n        // Called as new String().\n        this.data = value;\n        return this;\n      } else {\n        // Called as String().\n        return value;\n      }\n    };\n    this.STRING = this.createNativeFunction(wrapper, true);\n    this.setProperty(scope, 'String', this.STRING);\n\n    // Static methods on String.\n    this.setProperty(\n      this.STRING,\n      'fromCharCode',\n      this.createNativeFunction(String.fromCharCode, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR\n    );\n\n    // Instance methods on String.\n    // Methods with exclusively primitive arguments.\n    var functions = [\n      'trim',\n      'toLowerCase',\n      'toUpperCase',\n      'toLocaleLowerCase',\n      'toLocaleUpperCase',\n      'charAt',\n      'charCodeAt',\n      'substring',\n      'slice',\n      'substr',\n      'indexOf',\n      'lastIndexOf',\n      'concat',\n    ];\n    for (var i = 0; i < functions.length; i++) {\n      this.setNativeFunctionPrototype(this.STRING, functions[i], String.prototype[functions[i]]);\n    }\n\n    wrapper = function(compareString, locales, options) {\n      locales = locales ? thisInterpreter.pseudoToNative(locales) : undefined;\n      options = options ? thisInterpreter.pseudoToNative(options) : undefined;\n      return String(this).localeCompare(compareString, locales, options);\n    };\n    this.setNativeFunctionPrototype(this.STRING, 'localeCompare', wrapper);\n\n    wrapper = function(separator, limit) {\n      if (thisInterpreter.isa(separator, thisInterpreter.REGEXP)) {\n        separator = separator.data;\n      }\n      var jsList = String(this).split(separator, limit);\n      return thisInterpreter.nativeToPseudo(jsList);\n    };\n    this.setNativeFunctionPrototype(this.STRING, 'split', wrapper);\n\n    wrapper = function(regexp) {\n      regexp = regexp ? regexp.data : undefined;\n      var match = String(this).match(regexp);\n      if (!match) {\n        return null;\n      }\n      return thisInterpreter.nativeToPseudo(match);\n    };\n    this.setNativeFunctionPrototype(this.STRING, 'match', wrapper);\n\n    wrapper = function(regexp) {\n      if (thisInterpreter.isa(regexp, thisInterpreter.REGEXP)) {\n        regexp = regexp.data;\n      }\n      return String(this).search(regexp);\n    };\n    this.setNativeFunctionPrototype(this.STRING, 'search', wrapper);\n\n    wrapper = function(substr, newSubstr) {\n      // Support for function replacements is the responsibility of a polyfill.\n      return String(this).replace(substr.data || substr, newSubstr);\n    };\n    this.setNativeFunctionPrototype(this.STRING, 'replace', wrapper);\n    // Add a polyfill to handle replace's second argument being a function.\n    this.polyfills_.push(\n      '(function() {',\n      'var replace_ = String.prototype.replace;',\n      'String.prototype.replace = function(substr, newSubstr) {',\n      \"if (typeof newSubstr !== 'function') {\",\n      // string.replace(string|regexp, string)\n      'return replace_.call(this, substr, newSubstr);',\n      '}',\n      'var str = this;',\n      'if (substr instanceof RegExp) {', // string.replace(regexp, function)\n      'var subs = [];',\n      'var m = substr.exec(str);',\n      'while (m) {',\n      'm.push(m.index, str);',\n      'var inject = newSubstr.apply(null, m);',\n      'subs.push([m.index, m[0].length, inject]);',\n      'm = substr.global ? substr.exec(str) : null;',\n      '}',\n      'for (var i = subs.length - 1; i >= 0; i--) {',\n      'str = str.substring(0, subs[i][0]) + subs[i][2] + ' + 'str.substring(subs[i][0] + subs[i][1]);',\n      '}',\n      '} else {', // string.replace(string, function)\n      'var i = str.indexOf(substr);',\n      'if (i !== -1) {',\n      'var inject = newSubstr(str.substr(i, substr.length), i, str);',\n      'str = str.substring(0, i) + inject + ' + 'str.substring(i + substr.length);',\n      '}',\n      '}',\n      'return str;',\n      '};',\n      '})();',\n      ''\n    );\n  }\n\n  /**\n   * Initialize the Boolean class.\n   * @param {!MyObject} scope Global scope.\n   */\n  public initBoolean(scope: MyObject) {\n    var thisInterpreter = this;\n    var wrapper;\n    // Boolean constructor.\n    wrapper = function(value) {\n      value = Boolean(value);\n      if (thisInterpreter.calledWithNew()) {\n        // Called as new Boolean().\n        this.data = value;\n        return this;\n      } else {\n        // Called as Boolean().\n        return value;\n      }\n    };\n    this.BOOLEAN = this.createNativeFunction(wrapper, true);\n    this.setProperty(scope, 'Boolean', this.BOOLEAN);\n  }\n\n  /**\n   * Initialize the Number class.\n   * @param {!MyObject} scope Global scope.\n   */\n  public initNumber(scope: MyObject) {\n    var thisInterpreter = this;\n    var wrapper;\n    // Number constructor.\n    wrapper = function(value) {\n      value = Number(value);\n      if (thisInterpreter.calledWithNew()) {\n        // Called as new Number().\n        this.data = value;\n        return this;\n      } else {\n        // Called as Number().\n        return value;\n      }\n    };\n    this.NUMBER = this.createNativeFunction(wrapper, true);\n    this.setProperty(scope, 'Number', this.NUMBER);\n\n    var numConsts = ['MAX_VALUE', 'MIN_VALUE', 'NaN', 'NEGATIVE_INFINITY', 'POSITIVE_INFINITY'];\n    for (var i = 0; i < numConsts.length; i++) {\n      this.setProperty(this.NUMBER, numConsts[i], Number[numConsts[i]], Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n    }\n\n    // Instance methods on Number.\n    wrapper = function(fractionDigits) {\n      try {\n        return Number(this).toExponential(fractionDigits);\n      } catch (e) {\n        // Throws if fractionDigits isn't within 0-20.\n        thisInterpreter.throwException(thisInterpreter.ERROR, e.message);\n      }\n    };\n    this.setNativeFunctionPrototype(this.NUMBER, 'toExponential', wrapper);\n\n    wrapper = function(digits) {\n      try {\n        return Number(this).toFixed(digits);\n      } catch (e) {\n        // Throws if digits isn't within 0-20.\n        thisInterpreter.throwException(thisInterpreter.ERROR, e.message);\n      }\n    };\n    this.setNativeFunctionPrototype(this.NUMBER, 'toFixed', wrapper);\n\n    wrapper = function(precision) {\n      try {\n        return Number(this).toPrecision(precision);\n      } catch (e) {\n        // Throws if precision isn't within range (depends on implementation).\n        thisInterpreter.throwException(thisInterpreter.ERROR, e.message);\n      }\n    };\n    this.setNativeFunctionPrototype(this.NUMBER, 'toPrecision', wrapper);\n\n    wrapper = function(radix) {\n      try {\n        return Number(this).toString(radix);\n      } catch (e) {\n        // Throws if radix isn't within 2-36.\n        thisInterpreter.throwException(thisInterpreter.ERROR, e.message);\n      }\n    };\n    this.setNativeFunctionPrototype(this.NUMBER, 'toString', wrapper);\n\n    wrapper = function(locales, options) {\n      locales = locales ? thisInterpreter.pseudoToNative(locales) : undefined;\n      options = options ? thisInterpreter.pseudoToNative(options) : undefined;\n      return Number(this).toLocaleString(locales, options);\n    };\n    this.setNativeFunctionPrototype(this.NUMBER, 'toLocaleString', wrapper);\n  }\n\n  /**\n   * Initialize the Date class.\n   * @param {!MyObject} scope Global scope.\n   */\n  public initDate(scope: MyObject) {\n    var thisInterpreter = this;\n    var wrapper;\n    // Date constructor.\n    wrapper = function(value, var_args) {\n      if (!thisInterpreter.calledWithNew()) {\n        // Called as Date().\n        // Calling Date() as a function returns a string, no arguments are heeded.\n        return Date();\n      }\n      // Called as new Date().\n      var args = [null].concat([].slice.call(arguments));\n      this.data = new (Function.prototype.bind.apply(Date, args))();\n      return this;\n    };\n    this.DATE = this.createNativeFunction(wrapper, true);\n    this.setProperty(scope, 'Date', this.DATE);\n\n    // Static methods on Date.\n    this.setProperty(\n      this.DATE,\n      'now',\n      this.createNativeFunction(Date.now, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR\n    );\n\n    this.setProperty(\n      this.DATE,\n      'parse',\n      this.createNativeFunction(Date.parse, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR\n    );\n\n    this.setProperty(\n      this.DATE,\n      'UTC',\n      this.createNativeFunction(Date.UTC, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR\n    );\n\n    // Instance methods on Date.\n    var functions = [\n      'getDate',\n      'getDay',\n      'getFullYear',\n      'getHours',\n      'getMilliseconds',\n      'getMinutes',\n      'getMonth',\n      'getSeconds',\n      'getTime',\n      'getTimezoneOffset',\n      'getUTCDate',\n      'getUTCDay',\n      'getUTCFullYear',\n      'getUTCHours',\n      'getUTCMilliseconds',\n      'getUTCMinutes',\n      'getUTCMonth',\n      'getUTCSeconds',\n      'getYear',\n      'setDate',\n      'setFullYear',\n      'setHours',\n      'setMilliseconds',\n      'setMinutes',\n      'setMonth',\n      'setSeconds',\n      'setTime',\n      'setUTCDate',\n      'setUTCFullYear',\n      'setUTCHours',\n      'setUTCMilliseconds',\n      'setUTCMinutes',\n      'setUTCMonth',\n      'setUTCSeconds',\n      'setYear',\n      'toDateString',\n      'toISOString',\n      'toJSON',\n      'toGMTString',\n      'toLocaleDateString',\n      'toLocaleString',\n      'toLocaleTimeString',\n      'toTimeString',\n      'toUTCString',\n    ];\n    for (var i = 0; i < functions.length; i++) {\n      wrapper = (function(nativeFunc) {\n        return function(var_args) {\n          var args = [];\n          for (var i = 0; i < arguments.length; i++) {\n            args[i] = thisInterpreter.pseudoToNative(arguments[i]);\n          }\n          return this.data[nativeFunc].apply(this.data, args);\n        };\n      })(functions[i]);\n      this.setNativeFunctionPrototype(this.DATE, functions[i], wrapper);\n    }\n  }\n\n  /**\n   * Initialize Regular Expression object.\n   * @param {!MyObject} scope Global scope.\n   */\n  public initRegExp(scope: MyObject) {\n    var thisInterpreter = this;\n    var wrapper;\n    // RegExp constructor.\n    wrapper = function(pattern, flags) {\n      if (thisInterpreter.calledWithNew()) {\n        // Called as new RegExp().\n        var rgx = <MyObject>this;\n      } else {\n        // Called as RegExp().\n        var rgx = thisInterpreter.createObjectProto(thisInterpreter.REGEXP_PROTO);\n      }\n      pattern = pattern ? pattern.toString() : '';\n      flags = flags ? flags.toString() : '';\n      thisInterpreter.populateRegExp(rgx, new RegExp(pattern, flags));\n      return rgx;\n    };\n    this.REGEXP = this.createNativeFunction(wrapper, true);\n    this.REGEXP_PROTO = this.REGEXP.properties['prototype'];\n    this.setProperty(scope, 'RegExp', this.REGEXP);\n\n    this.setProperty(\n      this.REGEXP.properties['prototype'],\n      'global',\n      undefined,\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR\n    );\n    this.setProperty(\n      this.REGEXP.properties['prototype'],\n      'ignoreCase',\n      undefined,\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR\n    );\n    this.setProperty(\n      this.REGEXP.properties['prototype'],\n      'multiline',\n      undefined,\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR\n    );\n    this.setProperty(\n      this.REGEXP.properties['prototype'],\n      'source',\n      '(?:)',\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR\n    );\n\n    wrapper = function(str) {\n      return this.data.test(str);\n    };\n    this.setNativeFunctionPrototype(this.REGEXP, 'test', wrapper);\n\n    wrapper = function(str) {\n      str = str.toString();\n      // Get lastIndex from wrapped regex, since this is settable.\n      this.data.lastIndex = Number(thisInterpreter.getProperty(this, 'lastIndex'));\n      var match = this.data.exec(str);\n      thisInterpreter.setProperty(this, 'lastIndex', this.data.lastIndex);\n\n      if (match) {\n        var result = thisInterpreter.createObjectProto(thisInterpreter.ARRAY_PROTO);\n        for (var i = 0; i < match.length; i++) {\n          thisInterpreter.setProperty(result, i, match[i]);\n        }\n        // match has additional properties.\n        thisInterpreter.setProperty(result, 'index', match.index);\n        thisInterpreter.setProperty(result, 'input', match.input);\n        return result;\n      }\n      return null;\n    };\n    this.setNativeFunctionPrototype(this.REGEXP, 'exec', wrapper);\n  }\n\n  /**\n   * Initialize the Error class.\n   * @param {!MyObject} scope Global scope.\n   */\n  public initError(scope: MyObject) {\n    var thisInterpreter = this;\n    // Error constructor.\n    this.ERROR = this.createNativeFunction(function(opt_message) {\n      if (thisInterpreter.calledWithNew()) {\n        // Called as new Error().\n        var newError = <MyObject>this;\n      } else {\n        // Called as Error().\n        var newError = thisInterpreter.createObject(thisInterpreter.ERROR);\n      }\n      if (opt_message) {\n        thisInterpreter.setProperty(newError, 'message', String(opt_message), Interpreter.NONENUMERABLE_DESCRIPTOR);\n      }\n      return newError;\n    }, true);\n    this.setProperty(scope, 'Error', this.ERROR);\n    this.setProperty(this.ERROR.properties['prototype'], 'message', '', Interpreter.NONENUMERABLE_DESCRIPTOR);\n    this.setProperty(this.ERROR.properties['prototype'], 'name', 'Error', Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n    var createErrorSubclass = function(name) {\n      var constructor = thisInterpreter.createNativeFunction(function(opt_message) {\n        if (thisInterpreter.calledWithNew()) {\n          // Called as new XyzError().\n          var newError = <MyObject>this;\n        } else {\n          // Called as XyzError().\n          var newError = thisInterpreter.createObject(constructor);\n        }\n        if (opt_message) {\n          thisInterpreter.setProperty(newError, 'message', String(opt_message), Interpreter.NONENUMERABLE_DESCRIPTOR);\n        }\n        return newError;\n      }, true);\n      thisInterpreter.setProperty(constructor, 'prototype', thisInterpreter.createObject(thisInterpreter.ERROR));\n      thisInterpreter.setProperty(\n        constructor.properties['prototype'],\n        'name',\n        name,\n        Interpreter.NONENUMERABLE_DESCRIPTOR\n      );\n      thisInterpreter.setProperty(scope, name, constructor);\n\n      return constructor;\n    };\n\n    this.EVAL_ERROR = createErrorSubclass('EvalError');\n    this.RANGE_ERROR = createErrorSubclass('RangeError');\n    this.REFERENCE_ERROR = createErrorSubclass('ReferenceError');\n    this.SYNTAX_ERROR = createErrorSubclass('SyntaxError');\n    this.TYPE_ERROR = createErrorSubclass('TypeError');\n    this.URI_ERROR = createErrorSubclass('URIError');\n  }\n\n  /**\n   * Initialize Math object.\n   * @param {!MyObject} scope Global scope.\n   */\n  public initMath(scope: MyObject) {\n    var thisInterpreter = this;\n    var myMath = this.createObjectProto(this.OBJECT_PROTO);\n    this.setProperty(scope, 'Math', myMath);\n    var mathConsts = ['E', 'LN2', 'LN10', 'LOG2E', 'LOG10E', 'PI', 'SQRT1_2', 'SQRT2'];\n    for (var i = 0; i < mathConsts.length; i++) {\n      this.setProperty(myMath, mathConsts[i], Math[mathConsts[i]], Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n    }\n    var numFunctions = [\n      'abs',\n      'acos',\n      'asin',\n      'atan',\n      'atan2',\n      'ceil',\n      'cos',\n      'exp',\n      'floor',\n      'log',\n      'max',\n      'min',\n      'pow',\n      'random',\n      'round',\n      'sin',\n      'sqrt',\n      'tan',\n    ];\n    for (var i = 0; i < numFunctions.length; i++) {\n      this.setProperty(\n        myMath,\n        numFunctions[i],\n        this.createNativeFunction(Math[numFunctions[i]], false),\n        Interpreter.NONENUMERABLE_DESCRIPTOR\n      );\n    }\n  }\n\n  /**\n   * Initialize JSON object.\n   * @param {!MyObject} scope Global scope.\n   */\n  public initJSON(scope: MyObject) {\n    var thisInterpreter = this;\n    var myJSON = thisInterpreter.createObjectProto(this.OBJECT_PROTO);\n    this.setProperty(scope, 'JSON', myJSON);\n\n    var wrapper = function(text) {\n      try {\n        var nativeObj = JSON.parse(text.toString());\n      } catch (e) {\n        thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR, e.message);\n      }\n      return thisInterpreter.nativeToPseudo(nativeObj);\n    };\n    this.setProperty(myJSON, 'parse', this.createNativeFunction(wrapper, false));\n\n    wrapper = function(value) {\n      var nativeObj = thisInterpreter.pseudoToNative(value);\n      try {\n        var str = JSON.stringify(nativeObj);\n      } catch (e) {\n        thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, e.message);\n      }\n      return str;\n    };\n    this.setProperty(myJSON, 'stringify', this.createNativeFunction(wrapper, false));\n  }\n\n  /**\n   * Is an object of a certain class?\n   * @param {MyValue} child Object to check.\n   * @param {MyObject} constructor Constructor of object.\n   * @return {boolean} True if object is the class or inherits from it.\n   *     False otherwise.\n   */\n  public isa(child: MyValue, constructor: MyObject) {\n    if (child === null || child === undefined || !constructor) {\n      return false;\n    }\n    var proto = constructor.properties['prototype'];\n    if (child === proto) {\n      return true;\n    }\n    // The first step up the prototype chain is harder since the child might be\n    // a primitive value.  Subsequent steps can just follow the .proto property.\n    var childObj = this.getPrototype(child);\n    while (childObj) {\n      if (childObj === proto) {\n        return true;\n      }\n      childObj = childObj.proto;\n    }\n    return false;\n  }\n\n  /**\n   * Is a value a legal integer for an array length?\n   * @param {MyValue} x Value to check.\n   * @return {number} Zero, or a positive integer if the value can be\n   *     converted to such.  NaN otherwise.\n   */\n  static legalArrayLength(x: MyValue) {\n    var n = (<number>x) >>> 0;\n    // Array length must be between 0 and 2^32-1 (inclusive).\n    return n === Number(x) ? n : NaN;\n  }\n\n  /**\n   * Is a value a legal integer for an array index?\n   * @param {MyValue} x Value to check.\n   * @return {number} Zero, or a positive integer if the value can be\n   *     converted to such.  NaN otherwise.\n   */\n  static legalArrayIndex(x: MyValue) {\n    var n = (<number>x) >>> 0;\n    // Array index cannot be 2^32-1, otherwise length would be 2^32.\n    // 0xffffffff is 2^32-1.\n    return String(n) === String(x) && n !== 0xffffffff ? n : NaN;\n  }\n\n  /**\n   * Create a new data object based on a constructor's prototype.\n   * @param {MyObject} constructor Parent constructor function,\n   *     or null if scope object.\n   * @return {!MyObject} New data object.\n   */\n  public createObject(constructor: MyObject) {\n    return this.createObjectProto(constructor && constructor.properties['prototype']);\n  }\n\n  /**\n   * Create a new data object based on a prototype.\n   * @param {MyObject} proto Prototype object.\n   * @return {!MyObject} New data object.\n   */\n  public createObjectProto(proto: MyObject) {\n    var obj = new MyObject(proto);\n    // Functions have prototype objects.\n    if (this.isa(obj, this.FUNCTION)) {\n      this.setProperty(obj, 'prototype', this.createObjectProto(this.OBJECT_PROTO || null));\n      obj.class = 'Function';\n    }\n    // Arrays have length.\n    if (this.isa(obj, this.ARRAY)) {\n      this.setProperty(obj, 'length', 0, { configurable: false, enumerable: false, writable: true });\n      obj.class = 'Array';\n    }\n    if (this.isa(obj, this.MAP)) {\n      this.setProperty(obj, 'size', 0, { configurable: false, enumerable: false, writable: true });\n      obj.class = 'Map';\n    }\n    if (this.isa(obj, this.SET)) {\n      this.setProperty(obj, 'size', 0, { configurable: false, enumerable: false, writable: true });\n      obj.class = 'Set';\n    }\n    if (this.isa(obj, this.ERROR)) {\n      obj.class = 'Error';\n    }\n    return obj;\n  }\n\n  /**\n   * Initialize a pseudo regular expression object based on a native regular\n   * expression object.\n   * @param {!MyObject} pseudoRegexp The existing object to set.\n   * @param {!RegExp} nativeRegexp The native regular expression.\n   */\n  public populateRegExp(pseudoRegexp: MyObject, nativeRegexp: RegExp) {\n    pseudoRegexp.data = nativeRegexp;\n    // lastIndex is settable, all others are read-only attributes\n    this.setProperty(pseudoRegexp, 'lastIndex', nativeRegexp.lastIndex, Interpreter.NONENUMERABLE_DESCRIPTOR);\n    this.setProperty(pseudoRegexp, 'source', nativeRegexp.source, Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n    this.setProperty(pseudoRegexp, 'global', nativeRegexp.global, Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n    this.setProperty(\n      pseudoRegexp,\n      'ignoreCase',\n      nativeRegexp.ignoreCase,\n      Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR\n    );\n    this.setProperty(pseudoRegexp, 'multiline', nativeRegexp.multiline, Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n  }\n\n  /**\n   * Create a new function.\n   * @param {!Object} node AST node defining the function.\n   * @param {!Object} scope Parent scope.\n   * @return {!MyObject} New function.\n   */\n  public createFunction(node: ESTree.FunctionDeclaration, scope: MyObject) {\n    var func = this.createObjectProto(this.FUNCTION_PROTO);\n    func.parentScope = scope;\n    func.node = node;\n    this.setProperty(func, 'length', func.node['params'].length, Interpreter.READONLY_DESCRIPTOR);\n    return func;\n  }\n\n  /**\n   * Create a new native function.\n   * @param {!Function} nativeFunc JavaScript function.\n   * @param {boolean=} opt_constructor If true, the function's\n   * prototype will have its constructor property set to the function.\n   * If false, the function cannot be called as a constructor (e.g. escape).\n   * Defaults to undefined.\n   * @return {!MyObject} New function.\n   */\n  public createNativeFunction(nativeFunc: NativeFunction, opt_constructor?: boolean) {\n    var func = this.createObjectProto(this.FUNCTION_PROTO);\n    func.nativeFunc = nativeFunc;\n    nativeFunc.id = this.functionCounter_++;\n    this.setProperty(func, 'length', nativeFunc.length, Interpreter.READONLY_DESCRIPTOR);\n    if (opt_constructor) {\n      this.setProperty(func.properties['prototype'], 'constructor', func, Interpreter.NONENUMERABLE_DESCRIPTOR);\n    } else if (opt_constructor === false) {\n      func.illegalConstructor = true;\n      this.setProperty(func, 'prototype', undefined);\n    }\n    return func;\n  }\n\n  /**\n   * Create a new native asynchronous function.\n   * @param {!Function} asyncFunc JavaScript function.\n   * @return {!MyObject} New function.\n   */\n  public createAsyncFunction(asyncFunc) {\n    var func = this.createObjectProto(this.FUNCTION_PROTO);\n    func.asyncFunc = asyncFunc;\n    asyncFunc.id = this.functionCounter_++;\n    this.setProperty(func, 'length', asyncFunc.length, Interpreter.READONLY_DESCRIPTOR);\n    return func;\n  }\n\n  /**\n   * Converts from a native JS object or value to a JS interpreter object.\n   * Can handle JSON-style values.\n   * @param {*} nativeObj The native JS object to be converted.\n   * @return {MyValue} The equivalent JS interpreter object.\n   */\n  public nativeToPseudo(nativeObj: any): MyValue {\n    if (\n      typeof nativeObj === 'boolean' ||\n      typeof nativeObj === 'number' ||\n      typeof nativeObj === 'string' ||\n      nativeObj === null ||\n      nativeObj === undefined\n    ) {\n      return nativeObj;\n    }\n\n    if (nativeObj instanceof RegExp) {\n      var pseudoRegexp = this.createObjectProto(this.REGEXP_PROTO);\n      this.populateRegExp(pseudoRegexp, nativeObj);\n      return pseudoRegexp;\n    }\n\n    if (nativeObj instanceof Function) {\n      var interpreter = this;\n      var wrapper = function() {\n        return interpreter.nativeToPseudo(\n          nativeObj.apply(\n            interpreter,\n            Array.prototype.slice.call(arguments).map(function(i) {\n              return interpreter.pseudoToNative(i);\n            })\n          )\n        );\n      };\n      return this.createNativeFunction(wrapper, undefined);\n    }\n\n    var pseudoObj: MyObject;\n    if (Array.isArray(nativeObj)) {\n      // Array.\n      pseudoObj = this.createObjectProto(this.ARRAY_PROTO);\n      for (var i = 0; i < nativeObj.length; i++) {\n        if (i in nativeObj) {\n          this.setProperty(pseudoObj, i, this.nativeToPseudo(nativeObj[i]));\n        }\n      }\n    } else {\n      // Object.\n      pseudoObj = this.createObjectProto(this.OBJECT_PROTO);\n      for (var key in nativeObj) {\n        this.setProperty(pseudoObj, key, this.nativeToPseudo(nativeObj[key]));\n      }\n    }\n    return pseudoObj;\n  }\n\n  /**\n   * Converts from a JS interpreter object to native JS object.\n   * Can handle JSON-style values, plus cycles.\n   * @param {MyValue} pseudoObj The JS interpreter object to be\n   * converted.\n   * @param {Object=} opt_cycles Cycle detection (used in recursive calls).\n   * @return {*} The equivalent native JS object or value.\n   */\n  public pseudoToNative(pseudoObj: MyValue, opt_cycles?: MyValueTable) {\n    if (\n      typeof pseudoObj === 'boolean' ||\n      typeof pseudoObj === 'number' ||\n      typeof pseudoObj === 'string' ||\n      pseudoObj === null ||\n      pseudoObj === undefined\n    ) {\n      return pseudoObj;\n    }\n\n    if (this.isa(pseudoObj, this.REGEXP)) {\n      // Regular expression.\n      return pseudoObj.data;\n    }\n\n    var cycles = opt_cycles || {\n      pseudo: [],\n      native: [],\n    };\n    var i = cycles.pseudo.indexOf(pseudoObj);\n    if (i !== -1) {\n      return cycles.native[i];\n    }\n    cycles.pseudo.push(pseudoObj);\n    var nativeObj;\n    if (this.isa(pseudoObj, this.ARRAY)) {\n      // Array.\n      nativeObj = [];\n      cycles.native.push(nativeObj);\n      var length = this.getProperty(pseudoObj, 'length');\n      for (var i = 0; i < length; i++) {\n        if (this.hasProperty(pseudoObj, i)) {\n          nativeObj[i] = this.pseudoToNative(this.getProperty(pseudoObj, i), cycles);\n        }\n      }\n    } else {\n      // Object.\n      nativeObj = {};\n      cycles.native.push(nativeObj);\n      var val;\n      for (var key in pseudoObj.properties) {\n        val = pseudoObj.properties[key];\n        nativeObj[key] = this.pseudoToNative(val, cycles);\n      }\n    }\n    cycles.pseudo.pop();\n    cycles.native.pop();\n    return nativeObj;\n  }\n\n  /**\n   * Look up the prototype for this value.\n   * @param {MyValue} value Data object.\n   * @return {MyObject} Prototype object, null if none.\n   */\n  public getPrototype(value: MyValue): MyObject {\n    switch (typeof value) {\n      case 'number':\n        return this.NUMBER.properties['prototype'];\n      case 'boolean':\n        return this.BOOLEAN.properties['prototype'];\n      case 'string':\n        return this.STRING.properties['prototype'];\n    }\n    if (value) {\n      return (<MyObject>value).proto;\n    }\n    return null;\n  }\n\n  /**\n   * Fetch a property value from a data object.\n   * @param {MyValue} obj Data object.\n   * @param {MyValue} name Name of property.\n   * @return {MyValue} Property value (may be undefined).\n   */\n  public getProperty(obj: MyValue, name: MyValue): MyValue {\n    name = String(name);\n    if (obj === undefined || obj === null) {\n      this.throwException(this.TYPE_ERROR, \"Cannot read property '\" + name + \"' of \" + obj);\n    }\n    if (name === 'length') {\n      // Special cases for magic length property.\n      if (this.isa(obj, this.STRING)) {\n        return String(obj).length;\n      }\n    } else if (name.charCodeAt(0) < 0x40) {\n      // Might have numbers in there?\n      // Special cases for string array indexing\n      if (this.isa(obj, this.STRING)) {\n        var n = Interpreter.legalArrayIndex(name);\n        if (!isNaN(n) && n < String(obj).length) {\n          return String(obj)[n];\n        }\n      }\n    }\n    do {\n      const myObj = <MyObject>obj;\n      if (myObj.properties && name in myObj.properties) {\n        var getter = myObj.getter[name];\n        if (getter) {\n          // Flag this function as being a getter and thus needing immediate\n          // execution (rather than being the value of the property).\n          getter.isGetter = true;\n          return getter;\n        }\n        return myObj.properties[name];\n      }\n    } while ((obj = this.getPrototype(obj)));\n    return undefined;\n  }\n\n  /**\n   * Does the named property exist on a data object.\n   * @param {MyValue} obj Data object.\n   * @param {MyValue} name Name of property.\n   * @return {boolean} True if property exists.\n   */\n  public hasProperty(obj: MyValue, name: MyValue) {\n    if (!obj['isObject']) {\n      throw TypeError('Primitive data type has no properties');\n    }\n    name = String(name);\n    if (name === 'length' && this.isa(obj, this.STRING)) {\n      return true;\n    }\n    if (this.isa(obj, this.STRING)) {\n      var n = Interpreter.legalArrayIndex(name);\n      if (!isNaN(n) && n < String(obj).length) {\n        return true;\n      }\n    }\n    do {\n      const myObj = <MyObject>obj;\n      if (myObj.properties && name in myObj.properties) {\n        return true;\n      }\n    } while ((obj = this.getPrototype(obj)));\n    return false;\n  }\n\n  /**\n   * Set a property value on a data object.\n   * @param {!MyObject} obj Data object.\n   * @param {MyValue} name Name of property.\n   * @param {MyValue|ReferenceError} value New property value.\n   *   Use ReferenceError if value is handled by descriptor instead.\n   * @param {Object=} opt_descriptor Optional descriptor object.\n   * @return {!MyObject|undefined} Returns a setter function if one\n   *     needs to be called, otherwise undefined.\n   */\n  public setProperty(\n    obj: MyObject,\n    name: MyValue,\n    value: MyValue | ReferenceErrorConstructor,\n    opt_descriptor?\n  ): MyObject {\n    name = String(name);\n    if (obj === undefined || obj === null) {\n      this.throwException(this.TYPE_ERROR, \"Cannot set property '\" + name + \"' of \" + obj);\n    }\n    if (\n      opt_descriptor &&\n      ('get' in opt_descriptor || 'set' in opt_descriptor) &&\n      ('value' in opt_descriptor || 'writable' in opt_descriptor)\n    ) {\n      this.throwException(\n        this.TYPE_ERROR,\n        'Invalid property descriptor. ' + 'Cannot both specify accessors and a value or writable attribute'\n      );\n    }\n    var strict = !this.stateStack || this.getScope().strict;\n    if (!obj.isObject) {\n      if (strict) {\n        this.throwException(this.TYPE_ERROR, \"Can't create property '\" + name + \"' on '\" + obj + \"'\");\n      }\n      return;\n    }\n    if (this.isa(obj, this.STRING)) {\n      var n = Interpreter.legalArrayIndex(name);\n      if (name === 'length' || (!isNaN(n) && n < String(obj).length)) {\n        // Can't set length or letters on String objects.\n        if (strict) {\n          this.throwException(\n            this.TYPE_ERROR,\n            'Cannot assign to read only ' + \"property '\" + name + \"' of String '\" + obj.data + \"'\"\n          );\n        }\n        return;\n      }\n    }\n    if (obj.class === 'Array') {\n      // Arrays have a magic length variable that is bound to the elements.\n      var length = obj.properties.length;\n      var i;\n      if (name === 'length') {\n        // Delete elements if length is smaller.\n        value = Interpreter.legalArrayLength(<number>value);\n        if (isNaN(value)) {\n          this.throwException(this.RANGE_ERROR, 'Invalid array length');\n        }\n        if (value < length) {\n          for (i in obj.properties) {\n            i = Interpreter.legalArrayIndex(i);\n            if (!isNaN(i) && value <= i) {\n              delete obj.properties[i];\n            }\n          }\n        }\n      } else if (!isNaN((i = Interpreter.legalArrayIndex(name)))) {\n        // Increase length if this index is larger.\n        obj.properties.length = Math.max(length, i + 1);\n      }\n    }\n    if (obj.preventExtensions && !(name in obj.properties)) {\n      if (strict) {\n        this.throwException(this.TYPE_ERROR, \"Can't add property '\" + name + \"', object is not extensible\");\n      }\n      return;\n    }\n    if (opt_descriptor) {\n      // Define the property.\n      if ('get' in opt_descriptor) {\n        if (opt_descriptor.get) {\n          obj.getter[name] = opt_descriptor.get;\n        } else {\n          delete obj.getter[name];\n        }\n      }\n      if ('set' in opt_descriptor) {\n        if (opt_descriptor.set) {\n          obj.setter[name] = opt_descriptor.set;\n        } else {\n          delete obj.setter[name];\n        }\n      }\n      var descriptor: MyDescriptor = {};\n      if ('configurable' in opt_descriptor) {\n        descriptor.configurable = opt_descriptor.configurable;\n      }\n      if ('enumerable' in opt_descriptor) {\n        descriptor.enumerable = opt_descriptor.enumerable;\n      }\n      if ('writable' in opt_descriptor) {\n        descriptor.writable = opt_descriptor.writable;\n        delete obj.getter[name];\n        delete obj.setter[name];\n      }\n      if ('value' in opt_descriptor) {\n        descriptor.value = opt_descriptor.value;\n        delete obj.getter[name];\n        delete obj.setter[name];\n      } else if (value !== ReferenceError) {\n        descriptor.value = value;\n        delete obj.getter[name];\n        delete obj.setter[name];\n      }\n      try {\n        Object.defineProperty(obj.properties, name, <any>descriptor);\n      } catch (e) {\n        this.throwException(this.TYPE_ERROR, 'Cannot redefine property: ' + name);\n      }\n    } else {\n      // Set the property.\n      if (value === ReferenceError) {\n        throw ReferenceError('Value not specified.');\n      }\n      // Determine the parent (possibly self) where the property is defined.\n      var defObj = obj;\n      while (!(name in defObj.properties)) {\n        defObj = this.getPrototype(defObj);\n        if (!defObj) {\n          // This is a new property.\n          defObj = obj;\n          break;\n        }\n      }\n      if (defObj.setter && defObj.setter[name]) {\n        return defObj.setter[name];\n      }\n      if (defObj.getter && defObj.getter[name]) {\n        if (strict) {\n          this.throwException(\n            this.TYPE_ERROR,\n            \"Cannot set property '\" + name + \"' of object '\" + obj + \"' which only has a getter\"\n          );\n        }\n      } else {\n        // No setter, simple assignment.\n        try {\n          obj.properties[name] = value;\n        } catch (e) {\n          if (strict) {\n            this.throwException(\n              this.TYPE_ERROR,\n              'Cannot assign to read only ' + \"property '\" + name + \"' of object '\" + obj + \"'\"\n            );\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Convenience method for adding a native function as a non-enumerable property\n   * onto an object's prototype.\n   * @param {!MyObject} obj Data object.\n   * @param {MyValue} name Name of property.\n   * @param {!Function} wrapper Function object.\n   */\n  private setNativeFunctionPrototype(obj: MyObject, name: MyValue, wrapper: Function) {\n    this.setProperty(\n      obj.properties['prototype'],\n      name,\n      this.createNativeFunction(wrapper, false),\n      Interpreter.NONENUMERABLE_DESCRIPTOR\n    );\n  }\n\n  /**\n   * Returns the current scope from the stateStack.\n   * @return {!MyObject} Current scope dictionary.\n   */\n  public getScope() {\n    var scope = this.stateStack[this.stateStack.length - 1].scope;\n    if (!scope) {\n      throw Error('No scope found.');\n    }\n    return scope;\n  }\n\n  /**\n   * Create a new scope dictionary.\n   * @param {!Object} node AST node defining the scope container\n   *     (e.g. a function).\n   * @param {MyObject} parentScope Scope to link to.\n   * @return {!MyObject} New scope.\n   */\n  public createScope(node: ESTree.Node, parentScope: MyObject) {\n    var scope = this.createObjectProto(null);\n    scope.parentScope = parentScope;\n    if (!parentScope) {\n      this.initGlobalScope(scope);\n    }\n    this.populateScope_(node, scope);\n\n    // Determine if this scope starts with 'use strict'.\n    scope.strict = false;\n    if (parentScope && parentScope.strict) {\n      scope.strict = true;\n    } else {\n      var firstNode = node['body'] && node['body'][0];\n      if (\n        firstNode &&\n        firstNode.expression &&\n        firstNode.expression['type'] === 'Literal' &&\n        firstNode.expression.value === 'use strict'\n      ) {\n        scope.strict = true;\n      }\n    }\n    return scope;\n  }\n\n  /**\n   * Create a new special scope dictionary. Similar to createScope(), but\n   * doesn't assume that the scope is for a function body.\n   * This is used for 'catch' clauses and 'with' statements.\n   * @param {!MyObject} parentScope Scope to link to.\n   * @param {MyObject=} opt_scope Optional object to transform into\n   *     scope.\n   * @return {!MyObject} New scope.\n   */\n  public createSpecialScope(parentScope: MyObject, opt_scope?: MyObject) {\n    if (!parentScope) {\n      throw Error('parentScope required');\n    }\n    var scope = opt_scope || this.createObjectProto(null);\n    scope.parentScope = parentScope;\n    scope.strict = parentScope.strict;\n    return scope;\n  }\n\n  /**\n   * Retrieves a value from the scope chain.\n   * @param {string} name Name of variable.\n   * @return {MyValue} Any value.\n   *   May be flagged as being a getter and thus needing immediate execution\n   *   (rather than being the value of the property).\n   */\n  public getValueFromScope(name: string): MyValue {\n    var scope = this.getScope();\n    while (scope && scope !== this.global) {\n      if (name in scope.properties) {\n        return scope.properties[name];\n      }\n      scope = scope.parentScope;\n    }\n    // The root scope is also an object which has inherited properties and\n    // could also have getters.\n    if (scope === this.global && this.hasProperty(scope, name)) {\n      return this.getProperty(scope, name);\n    }\n    // Typeof operator is unique: it can safely look at non-defined variables.\n    var prevNode = this.stateStack[this.stateStack.length - 1].node;\n    if (prevNode['type'] === 'UnaryExpression' && prevNode['operator'] === 'typeof') {\n      return undefined;\n    }\n    this.throwException(this.REFERENCE_ERROR, name + ' is not defined');\n  }\n\n  /**\n   * Sets a value to the current scope.\n   * @param {string} name Name of variable.\n   * @param {MyValue} value Value.\n   * @return {!MyObject|undefined} Returns a setter function if one\n   *     needs to be called, otherwise undefined.\n   */\n  public setValueToScope(name: string, value: MyValue) {\n    var scope = this.getScope();\n    var strict = scope.strict;\n    while (scope && scope !== this.global) {\n      if (name in scope.properties) {\n        scope.properties[name] = value;\n        return undefined;\n      }\n      scope = scope.parentScope;\n    }\n    // The root scope is also an object which has readonly properties and\n    // could also have setters.\n    if (scope === this.global && (!strict || this.hasProperty(scope, name))) {\n      return this.setProperty(scope, name, value);\n    }\n    this.throwException(this.REFERENCE_ERROR, name + ' is not defined');\n  }\n\n  /**\n   * Create a new scope for the given node.\n   * @param {!Object} node AST node (program or function).\n   * @param {!MyObject} scope Scope dictionary to populate.\n   * @private\n   */\n  public populateScope_(node: ESTree.Node, scope: MyObject) {\n    if (node['type'] === 'VariableDeclaration') {\n      for (var i = 0; i < node['declarations'].length; i++) {\n        this.setProperty(scope, node['declarations'][i]['id']['name'], undefined, Interpreter.VARIABLE_DESCRIPTOR);\n      }\n    } else if (node['type'] === 'FunctionDeclaration') {\n      this.setProperty(\n        scope,\n        node['id']['name'],\n        this.createFunction(<ESTree.FunctionDeclaration>node, scope),\n        Interpreter.VARIABLE_DESCRIPTOR\n      );\n      return; // Do not recurse into function.\n    } else if (node['type'] === 'FunctionExpression') {\n      return; // Do not recurse into function.\n    } else if (node['type'] === 'ExpressionStatement') {\n      return; // Expressions can't contain variable/function declarations.\n    }\n    var nodeClass = node['constructor'];\n    for (var name in node) {\n      var prop = node[name];\n      if (prop && typeof prop === 'object') {\n        if (Array.isArray(prop)) {\n          for (var i = 0; i < prop.length; i++) {\n            if (prop[i] && prop[i].constructor === nodeClass) {\n              this.populateScope_(prop[i], scope);\n            }\n          }\n        } else {\n          if (prop.constructor === nodeClass) {\n            this.populateScope_(prop, scope);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Remove start and end values from AST, or set start and end values to a\n   * constant value.  Used to remove highlighting from polyfills and to set\n   * highlighting in an eval to cover the entire eval expression.\n   * @param {!Object} node AST node.\n   * @param {number=} start Starting character of all nodes, or undefined.\n   * @param {number=} end Ending character of all nodes, or undefined.\n   * @private\n   */\n  private stripLocations_(node: ESTree.BaseNode, start: number, end: number) {\n    if (start) {\n      node['start'] = start;\n    } else {\n      delete node['start'];\n    }\n    if (end) {\n      node['end'] = end;\n    } else {\n      delete node['end'];\n    }\n    for (var name in node) {\n      if (node.hasOwnProperty(name)) {\n        var prop = node[name];\n        if (prop && typeof prop === 'object') {\n          this.stripLocations_(prop, start, end);\n        }\n      }\n    }\n  }\n\n  /**\n   * Is the current state directly being called with as a construction with 'new'.\n   * @return {boolean} True if 'new foo()', false if 'foo()'.\n   */\n  public calledWithNew(): boolean {\n    return this.stateStack[this.stateStack.length - 1].isConstructor;\n  }\n\n  /**\n   * Gets a value from the scope chain or from an object property.\n   * @param {!Array} ref Name of variable or object/propname tuple.\n   * @return {MyValue} Any value.\n   *   May be flagged as being a getter and thus needing immediate execution\n   *   (rather than being the value of the property).\n   */\n  public getValue(ref) {\n    if (ref[0] === Interpreter.SCOPE_REFERENCE) {\n      // A null/varname variable lookup.\n      return this.getValueFromScope(ref[1]);\n    } else {\n      // An obj/prop components tuple (foo.bar).\n      return this.getProperty(ref[0], ref[1]);\n    }\n  }\n\n  /**\n   * Sets a value to the scope chain or to an object property.\n   * @param {!Array} ref Name of variable or object/propname tuple.\n   * @param {MyValue} value Value.\n   * @return {!MyObject|undefined} Returns a setter function if one\n   *     needs to be called, otherwise undefined.\n   */\n  public setValue(ref: Array<any> & { 0: MyObject; 1: string }, value: MyValue) {\n    if (ref[0] === Interpreter.SCOPE_REFERENCE) {\n      // A null/varname variable lookup.\n      return this.setValueToScope(ref[1], value);\n    } else {\n      // An obj/prop components tuple (foo.bar).\n      return this.setProperty(ref[0], ref[1], value);\n    }\n  }\n\n  /**\n   * Throw an exception in the interpreter that can be handled by an\n   * interpreter try/catch statement.  If unhandled, a real exception will\n   * be thrown.  Can be called with either an error class and a message, or\n   * with an actual object to be thrown.\n   * @param {!MyObject} errorClass Type of error (if message is\n   *   provided) or the value to throw (if no message).\n   * @param {string=} opt_message Message being thrown.\n   */\n  public throwException(errorClass: MyObject, opt_message?: string) {\n    if (opt_message === undefined) {\n      var error = <MyObject>errorClass; // This is a value to throw, not an error class.\n    } else {\n      var error = this.createObject(errorClass);\n      this.setProperty(error, 'message', opt_message, Interpreter.NONENUMERABLE_DESCRIPTOR);\n    }\n    this.executeException(error);\n    // Abort anything related to the current step.\n    throw Interpreter.STEP_ERROR;\n  }\n\n  /**\n   * Throw an exception in the interpreter that can be handled by a\n   * interpreter try/catch statement.  If unhandled, a real exception will\n   * be thrown.\n   * @param {!MyObject} error Error object to execute.\n   */\n  public executeException(error: MyObject) {\n    // Search for a try statement.\n    const stateStack = this.stateStack.slice();\n    do {\n      this.stateStack.pop();\n      var state = this.stateStack[this.stateStack.length - 1];\n      if (state.node['type'] === 'TryStatement') {\n        state.throwValue = error;\n        return;\n      }\n    } while (state && state.node['type'] !== 'Program');\n\n    // Throw a real error.\n    var realError;\n    if (this.isa(error, this.ERROR)) {\n      var errorTable = {\n        EvalError: EvalError,\n        RangeError: RangeError,\n        ReferenceError: ReferenceError,\n        SyntaxError: SyntaxError,\n        TypeError: TypeError,\n        URIError: URIError,\n      };\n      var name = this.getProperty(error, 'name').toString();\n      var message = this.getProperty(error, 'message').valueOf();\n      var type = errorTable[name] || Error;\n      realError = type(message);\n    } else {\n      realError = String(error);\n    }\n    this.stateStack = stateStack; // recover the original state stack\n    throw realError;\n  }\n\n  /**\n   * Create a call to a getter function.\n   * @param {!MyObject} func Function to execute.\n   * @param {!MyObject|!Array} left\n   *     Name of variable or object/propname tuple.\n   * @private\n   */\n  public createGetter_(func: MyObject, left: MyObject | Array<MyObject>) {\n    // Normally 'this' will be specified as the object component (o.x).\n    // Sometimes 'this' is explicitly provided (o).\n    var funcThis = Array.isArray(left) ? left[0] : left;\n    var node = new this.nodeConstructor({ options: {} });\n    node['type'] = 'CallExpression';\n    var state = new MyState(node, this.stateStack[this.stateStack.length - 1].scope);\n    state.doneCallee_ = true;\n    state.funcThis_ = funcThis;\n    state.func_ = func;\n    state.doneArgs_ = true;\n    state.arguments_ = [];\n    return state;\n  }\n\n  /**\n   * Create a call to a setter function.\n   * @param {!MyObject} func Function to execute.\n   * @param {!MyObject|!Array} left\n   *     Name of variable or object/propname tuple.\n   * @param {MyValue} value Value to set.\n   * @private\n   */\n  public createSetter_(func: MyObject, left: MyObject | Array<MyObject>, value: MyValue) {\n    // Normally 'this' will be specified as the object component (o.x).\n    // Sometimes 'this' is implicitly the global object (x).\n    var funcThis = Array.isArray(left) ? left[0] : this.global;\n    var node = new this.nodeConstructor({ options: {} });\n    node['type'] = 'CallExpression';\n    var state = new MyState(node, this.stateStack[this.stateStack.length - 1].scope);\n    state.doneCallee_ = true;\n    state.funcThis_ = funcThis;\n    state.func_ = func;\n    state.doneArgs_ = true;\n    state.arguments_ = [value];\n    return state;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////\n  // Functions to handle each node type.\n  ///////////////////////////////////////////////////////////////////////////////\n\n  private stepArrayExpression(stack: MyState[], state: MyState, node: ESTree.Node) {\n    var elements = node['elements'];\n    var n = state.n_ || 0;\n    if (!state.array_) {\n      state.array_ = this.createObjectProto(this.ARRAY_PROTO);\n      state.array_.properties.length = elements.length;\n    } else {\n      this.setProperty(state.array_, n, state.value);\n      n++;\n    }\n    while (n < elements.length) {\n      // Skip missing elements - they're not defined, not undefined.\n      if (elements[n]) {\n        state.n_ = n;\n        return new MyState(elements[n], state.scope);\n      }\n      n++;\n    }\n    stack.pop();\n    stack[stack.length - 1].value = state.array_;\n  }\n\n  private stepAssignmentExpression(stack: MyState[], state: MyState, node: ESTree.Node) {\n    if (!state.doneLeft_) {\n      state.doneLeft_ = true;\n      var nextState = new MyState(node['left'], state.scope);\n      nextState.components = true;\n      return nextState;\n    }\n    if (!state.doneRight_) {\n      if (!state.leftReference_) {\n        state.leftReference_ = state.value;\n      }\n      if (state.doneGetter_) {\n        state.leftValue_ = state.value;\n      }\n      if (!state.doneGetter_ && node['operator'] !== '=') {\n        var leftValue = this.getValue(state.leftReference_);\n        state.leftValue_ = leftValue;\n        if (leftValue && typeof leftValue === 'object' && leftValue.isGetter) {\n          // Clear the getter flag and call the getter function.\n          leftValue.isGetter = false;\n          state.doneGetter_ = true;\n          var func = /** @type {!Interpreter.Object} */ leftValue;\n          return this.createGetter_(func, state.leftReference_);\n        }\n      }\n      state.doneRight_ = true;\n      return new MyState(node['right'], state.scope);\n    }\n    if (state.doneSetter_) {\n      // Return if setter function.\n      // Setter method on property has completed.\n      // Ignore its return value, and use the original set value instead.\n      stack.pop();\n      stack[stack.length - 1].value = state.doneSetter_;\n      return;\n    }\n    var value = state.leftValue_;\n    var rightValue = state.value;\n    switch (node['operator']) {\n      case '=':\n        value = rightValue;\n        break;\n      case '+=':\n        value += rightValue;\n        break;\n      case '-=':\n        value -= rightValue;\n        break;\n      case '*=':\n        value *= rightValue;\n        break;\n      case '/=':\n        value /= rightValue;\n        break;\n      case '%=':\n        value %= rightValue;\n        break;\n      case '<<=':\n        value <<= rightValue;\n        break;\n      case '>>=':\n        value >>= rightValue;\n        break;\n      case '>>>=':\n        value >>>= rightValue;\n        break;\n      case '&=':\n        value &= rightValue;\n        break;\n      case '^=':\n        value ^= rightValue;\n        break;\n      case '|=':\n        value |= rightValue;\n        break;\n      default:\n        throw SyntaxError('Unknown assignment expression: ' + node['operator']);\n    }\n    var setter = this.setValue(state.leftReference_, value);\n    if (setter) {\n      state.doneSetter_ = value;\n      return this.createSetter_(setter, state.leftReference_, value);\n    }\n    // Return if no setter function.\n    stack.pop();\n    stack[stack.length - 1].value = value;\n  }\n\n  private stepBinaryExpression(stack: MyState[], state: MyState, node: ESTree.Node) {\n    if (!state.doneLeft_) {\n      state.doneLeft_ = true;\n      return new MyState(node['left'], state.scope);\n    }\n    if (!state.doneRight_) {\n      state.doneRight_ = true;\n      state.leftValue_ = state.value;\n      return new MyState(node['right'], state.scope);\n    }\n    stack.pop();\n    var leftValue = state.leftValue_;\n    var rightValue = state.value;\n    var value;\n    switch (node['operator']) {\n      case '==':\n        value = leftValue == rightValue;\n        break;\n      case '!=':\n        value = leftValue != rightValue;\n        break;\n      case '===':\n        value = leftValue === rightValue;\n        break;\n      case '!==':\n        value = leftValue !== rightValue;\n        break;\n      case '>':\n        value = leftValue > rightValue;\n        break;\n      case '>=':\n        value = leftValue >= rightValue;\n        break;\n      case '<':\n        value = leftValue < rightValue;\n        break;\n      case '<=':\n        value = leftValue <= rightValue;\n        break;\n      case '+':\n        value = leftValue + rightValue;\n        break;\n      case '-':\n        value = leftValue - rightValue;\n        break;\n      case '*':\n        value = leftValue * rightValue;\n        break;\n      case '/':\n        value = leftValue / rightValue;\n        break;\n      case '%':\n        value = leftValue % rightValue;\n        break;\n      case '&':\n        value = leftValue & rightValue;\n        break;\n      case '|':\n        value = leftValue | rightValue;\n        break;\n      case '^':\n        value = leftValue ^ rightValue;\n        break;\n      case '<<':\n        value = leftValue << rightValue;\n        break;\n      case '>>':\n        value = leftValue >> rightValue;\n        break;\n      case '>>>':\n        value = leftValue >>> rightValue;\n        break;\n      case 'in':\n        if (!rightValue || !rightValue.isObject) {\n          this.throwException(this.TYPE_ERROR, \"'in' expects an object, not '\" + rightValue + \"'\");\n        }\n        value = this.hasProperty(rightValue, leftValue);\n        break;\n      case 'instanceof':\n        if (!this.isa(rightValue, this.FUNCTION)) {\n          this.throwException(this.TYPE_ERROR, 'Right-hand side of instanceof is not an object');\n        }\n        value = leftValue.isObject ? this.isa(leftValue, rightValue) : false;\n        break;\n      default:\n        throw SyntaxError('Unknown binary operator: ' + node['operator']);\n    }\n    stack[stack.length - 1].value = value;\n  }\n\n  private stepBlockStatement(stack: MyState[], state: MyState, node: ESTree.Node) {\n    var n = state.n_ || 0;\n    var expression = node['body'][n];\n    if (expression) {\n      state.n_ = n + 1;\n      return new MyState(expression, state.scope);\n    }\n    stack.pop();\n  }\n\n  private stepBreakStatement(stack: MyState[], state: MyState, node: ESTree.Node) {\n    stack.pop();\n    var label = null;\n    if (node['label']) {\n      label = node['label']['name'];\n    }\n    while (state && state.node['type'] !== 'CallExpression' && state.node['type'] !== 'NewExpression') {\n      if (label) {\n        if (state.labels && state.labels.indexOf(label) !== -1) {\n          return;\n        }\n      } else if (state.isLoop || state.isSwitch) {\n        return;\n      }\n      state = stack.pop();\n    }\n    // Syntax error, do not allow this error to be trapped.\n    throw SyntaxError('Illegal break statement');\n  }\n\n  private stepCallExpression(stack: MyState[], state: MyState, node: ESTree.Node) {\n    if (!state.doneCallee_) {\n      state.doneCallee_ = 1;\n      // Components needed to determine value of 'this'.\n      var nextState = new MyState(node['callee'], state.scope);\n      nextState.components = true;\n      return nextState;\n    }\n    if (state.doneCallee_ === 1) {\n      // Determine value of the function.\n      state.doneCallee_ = 2;\n      var func = state.value;\n      if (Array.isArray(func)) {\n        state.func_ = this.getValue(func);\n        if (func[0] !== Interpreter.SCOPE_REFERENCE) {\n          // Method function, 'this' is object (ignored if invoked as 'new').\n          state.funcThis_ = func[0];\n        }\n        func = state.func_;\n        if (func && typeof func === 'object' && func.isGetter) {\n          // Clear the getter flag and call the getter function.\n          func.isGetter = false;\n          state.doneCallee_ = 1;\n          return this.createGetter_(/** @type {!Interpreter.Object} */ func, state.value);\n        }\n      } else {\n        // Already evaluated function: (function(){...})();\n        state.func_ = func;\n      }\n      state.arguments_ = [];\n      state.n_ = 0;\n    }\n    var func = state.func_;\n    if (!state.doneArgs_) {\n      if (state.n_ !== 0) {\n        state.arguments_.push(state.value);\n      }\n      if (node['arguments'][state.n_]) {\n        return new MyState(node['arguments'][state.n_++], state.scope);\n      }\n      // Determine value of 'this' in function.\n      if (node['type'] === 'NewExpression') {\n        if (func.illegalConstructor) {\n          // Illegal: new escape();\n          this.throwException(this.TYPE_ERROR, func + ' is not a constructor');\n        }\n        // Constructor, 'this' is new object.\n        state.funcThis_ = this.createObject(func);\n        state.isConstructor = true;\n      } else if (state.funcThis_ === undefined) {\n        // Global function, 'this' is global object (or 'undefined' if strict).\n        state.funcThis_ = state.scope.strict ? undefined : this.global;\n      }\n      state.doneArgs_ = true;\n    }\n    if (!state.doneExec_) {\n      state.doneExec_ = true;\n      if (!func || !func.isObject) {\n        this.throwException(this.TYPE_ERROR, func + ' is not a function');\n      }\n      var funcNode = func.node;\n      if (funcNode) {\n        var scope = this.createScope(funcNode['body'], func.parentScope);\n        // Add all arguments.\n        for (var i = 0; i < funcNode['params'].length; i++) {\n          var paramName = funcNode['params'][i]['name'];\n          var paramValue = state.arguments_.length > i ? state.arguments_[i] : undefined;\n          this.setProperty(scope, paramName, paramValue);\n        }\n        // Build arguments variable.\n        var argsList = this.createObjectProto(this.ARRAY_PROTO);\n        for (var i = 0; i < state.arguments_.length; i++) {\n          this.setProperty(argsList, i, state.arguments_[i]);\n        }\n        this.setProperty(scope, 'arguments', argsList);\n        // Add the function's name (var x = function foo(){};)\n        var name = funcNode['id'] && funcNode['id']['name'];\n        if (name) {\n          this.setProperty(scope, name, func);\n        }\n        this.setProperty(scope, 'this', state.funcThis_, Interpreter.READONLY_DESCRIPTOR);\n        state.value = undefined; // Default value if no explicit return.\n        return new MyState(funcNode['body'], scope);\n      } else if (func.eval) {\n        var code = state.arguments_[0];\n        if (typeof code !== 'string') {\n          // JS does not parse String objects:\n          // eval(new String('1 + 1')) -> '1 + 1'\n          state.value = code;\n        } else {\n          try {\n            var ast = acorn.parse(code.toString(), Interpreter.PARSE_OPTIONS);\n          } catch (e) {\n            // Acorn threw a SyntaxError.  Rethrow as a trappable error.\n            this.throwException(this.SYNTAX_ERROR, 'Invalid code: ' + e.message);\n          }\n          var evalNode = new this.nodeConstructor({ options: {} });\n          evalNode['type'] = 'EvalProgram_';\n          evalNode['body'] = ast['body'];\n          this.stripLocations_(evalNode, node['start'], node['end']);\n          // Update current scope with definitions in eval().\n          var scope = <MyObject>state.scope;\n          if (scope.strict) {\n            // Strict mode get its own scope in eval.\n            scope = this.createScope(ast, scope);\n          } else {\n            // Non-strict mode pollutes the current scope.\n            this.populateScope_(ast, scope);\n          }\n          this.value = undefined; // Default value if no code.\n          return new MyState(evalNode, scope);\n        }\n      } else if (func.nativeFunc) {\n        state.value = func.nativeFunc.apply(state.funcThis_, state.arguments_);\n      } else if (func.asyncFunc) {\n        var thisInterpreter = this;\n        var callback = function(value) {\n          state.value = value;\n          thisInterpreter.paused_ = false;\n        };\n        var argsWithCallback = state.arguments_.concat(callback);\n        this.paused_ = true;\n        func.asyncFunc.apply(state.funcThis_, argsWithCallback);\n        return;\n      } else {\n        /* A child of a function is a function but is not callable.  For example:\n      var F = function() {};\n      F.prototype = escape;\n      var f = new F();\n      f();\n      */\n        this.throwException(this.TYPE_ERROR, func.class + ' is not a function');\n      }\n    } else {\n      // Execution complete.  Put the return value on the stack.\n      stack.pop();\n      if (state.isConstructor && typeof state.value !== 'object') {\n        stack[stack.length - 1].value = state.funcThis_;\n      } else {\n        stack[stack.length - 1].value = state.value;\n      }\n    }\n  }\n\n  private stepCatchClause(stack: MyState[], state: MyState, node: ESTree.Node) {\n    if (!state.done_) {\n      state.done_ = true;\n      // Create an empty scope.\n      var scope = this.createSpecialScope(state.scope);\n      // Add the argument.\n      this.setProperty(scope, node['param']['name'], state.throwValue);\n      // Execute catch clause.\n      return new MyState(node['body'], scope);\n    } else {\n      stack.pop();\n    }\n  }\n\n  private stepConditionalExpression(stack: MyState[], state: MyState, node: ESTree.Node) {\n    var mode = state.mode_ || 0;\n    if (mode === 0) {\n      state.mode_ = 1;\n      return new MyState(node['test'], state.scope);\n    }\n    if (mode === 1) {\n      state.mode_ = 2;\n      var value = Boolean(state.value);\n      if (value && node['consequent']) {\n        // Execute 'if' block.\n        return new MyState(node['consequent'], state.scope);\n      } else if (!value && node['alternate']) {\n        // Execute 'else' block.\n        return new MyState(node['alternate'], state.scope);\n      }\n      // eval('1;if(false){2}') -> undefined\n      this.value = undefined;\n    }\n    stack.pop();\n    if (node['type'] === 'ConditionalExpression') {\n      stack[stack.length - 1].value = state.value;\n    }\n  }\n\n  private stepContinueStatement(stack: MyState[], state: MyState, node: ESTree.Node) {\n    stack.pop();\n    var label = null;\n    if (node['label']) {\n      label = node['label']['name'];\n    }\n    state = stack[stack.length - 1];\n    while (state && state.node['type'] !== 'CallExpression' && state.node['type'] !== 'NewExpression') {\n      if (state.isLoop) {\n        if (!label || (state.labels && state.labels.indexOf(label) !== -1)) {\n          return;\n        }\n      }\n      stack.pop();\n      state = stack[stack.length - 1];\n    }\n    // Syntax error, do not allow this error to be trapped.\n    throw SyntaxError('Illegal continue statement');\n  }\n\n  private stepDebuggerStatement(stack: MyState[], state: MyState, node: ESTree.Node) {\n    // Do nothing.  May be overridden by developers.\n    stack.pop();\n  }\n\n  private stepDoWhileStatement(stack: MyState[], state: MyState, node: ESTree.Node) {\n    if (node['type'] === 'DoWhileStatement' && state.test_ === undefined) {\n      // First iteration of do/while executes without checking test.\n      state.value = true;\n      state.test_ = true;\n    }\n    if (!state.test_) {\n      state.test_ = true;\n      return new MyState(node['test'], state.scope);\n    }\n    if (!state.value) {\n      // Done, exit loop.\n      stack.pop();\n    } else if (node['body']) {\n      // Execute the body.\n      state.test_ = false;\n      state.isLoop = true;\n      return new MyState(node['body'], state.scope);\n    }\n  }\n\n  private stepEmptyStatement(stack: MyState[], state: MyState, node: ESTree.Node) {\n    stack.pop();\n  }\n\n  private stepEvalProgram_(stack: MyState[], state: MyState, node: ESTree.Node) {\n    var n = state.n_ || 0;\n    var expression = node['body'][n];\n    if (expression) {\n      state.n_ = n + 1;\n      return new MyState(expression, state.scope);\n    }\n    stack.pop();\n    stack[stack.length - 1].value = this.value;\n  }\n\n  private stepExpressionStatement(stack: MyState[], state: MyState, node: ESTree.Node) {\n    if (!state.done_) {\n      state.done_ = true;\n      return new MyState(node['expression'], state.scope);\n    }\n    stack.pop();\n    // Save this value to interpreter.value for use as a return value if\n    // this code is inside an eval function.\n    this.value = state.value;\n  }\n\n  private stepForInStatement(stack: MyState[], state: MyState, node: ESTree.Node) {\n    // First, initialize a variable if exists.  Only do so once, ever.\n    if (!state.doneInit_) {\n      state.doneInit_ = true;\n      if (node['left']['declarations'] && node['left']['declarations'][0]['init']) {\n        if (state.scope.strict) {\n          this.throwException(this.SYNTAX_ERROR, 'for-in loop variable declaration may not have an initializer.');\n        }\n        // Variable initialization: for (var x = 4 in y)\n        return new MyState(node['left'], state.scope);\n      }\n    }\n    // Second, look up the object.  Only do so once, ever.\n    if (!state.doneObject_) {\n      state.doneObject_ = true;\n      if (!state.variable_) {\n        state.variable_ = state.value;\n      }\n      return new MyState(node['right'], state.scope);\n    }\n    if (!state.isLoop) {\n      // First iteration.\n      state.isLoop = true;\n      state.object_ = state.value;\n      state.visited_ = Object.create(null);\n    }\n    // Third, find the property name for this iteration.\n    if (state.name_ === undefined) {\n      done: do {\n        if (state.object_ && state.object_.isObject) {\n          if (!state.props_) {\n            state.props_ = Object.getOwnPropertyNames(state.object_.properties);\n          }\n          do {\n            var prop = state.props_.shift();\n          } while (\n            prop &&\n            (state.visited_[prop] || !Object.prototype.hasOwnProperty.call(state.object_.properties, prop))\n          );\n          if (prop) {\n            state.visited_[prop] = true;\n            if (Object.prototype.propertyIsEnumerable.call(state.object_.properties, prop)) {\n              state.name_ = prop;\n              break done;\n            }\n          }\n        } else if (state.object_ !== null) {\n          if (!state.props_) {\n            state.props_ = Object.getOwnPropertyNames(state.object_);\n          }\n          do {\n            var prop = state.props_.shift();\n          } while (prop && state.visited_[prop]);\n          if (prop) {\n            state.visited_[prop] = true;\n            state.name_ = prop;\n            break done;\n          }\n        }\n        state.object_ = this.getPrototype(state.object_);\n        state.props_ = null;\n      } while (state.object_ !== null);\n      if (state.object_ === null) {\n        // Done, exit loop.\n        stack.pop();\n        return;\n      }\n    }\n    // Fourth, find the variable\n    if (!state.doneVariable_) {\n      state.doneVariable_ = true;\n      var left = node['left'];\n      if (left['type'] === 'VariableDeclaration') {\n        // Inline variable declaration: for (var x in y)\n        state.variable_ = [Interpreter.SCOPE_REFERENCE, left['declarations'][0]['id']['name']];\n      } else {\n        // Arbitrary left side: for (foo().bar in y)\n        state.variable_ = null;\n        var nextState = new MyState(left, state.scope);\n        nextState.components = true;\n        return nextState;\n      }\n    }\n    if (!state.variable_) {\n      state.variable_ = state.value;\n    }\n    // Fifth, set the variable.\n    if (!state.doneSetter_) {\n      state.doneSetter_ = true;\n      var value = state.name_;\n      var setter = this.setValue(state.variable_, value);\n      if (setter) {\n        return this.createSetter_(setter, state.variable_, value);\n      }\n    }\n    // Next step will be step three.\n    state.name_ = undefined;\n    // Reevaluate the variable since it could be a setter on the global object.\n    state.doneVariable_ = false;\n    state.doneSetter_ = false;\n    // Sixth and finally, execute the body if there was one.  this.\n    if (node['body']) {\n      return new MyState(node['body'], state.scope);\n    }\n  }\n\n  private stepForOfStatement(stack: MyState[], state: MyState, node: ESTree.Node) {\n    // First, initialize a variable if exists.  Only do so once, ever.\n    if (!state.doneInit_) {\n      state.doneInit_ = true;\n      if (node['left']['declarations'] && node['left']['declarations'][0]['init']) {\n        if (state.scope.strict) {\n          this.throwException(this.SYNTAX_ERROR, 'for-of loop variable declaration may not have an initializer.');\n        }\n        // Variable initialization: for (var x = 4 in y)\n        return new MyState(node['left'], state.scope);\n      }\n    }\n    // Second, look up the object.  Only do so once, ever.\n    if (!state.doneObject_) {\n      state.doneObject_ = true;\n      if (!state.variable_) {\n        state.variable_ = state.value;\n      }\n      return new MyState(node['right'], state.scope);\n    }\n    if (!state.isLoop) {\n      // First iteration.\n      state.isLoop = true;\n      state.object_ = state.value;\n      state.visited_ = Object.create(null);\n    }\n    // Third, find the property name for this iteration.\n    if (state.name_ === undefined) {\n      done: do {\n        if (state.object_) {\n          const isIterable = obj => obj != null && typeof obj[Symbol.iterator] === 'function';\n          if (!state.itr_) {\n            if (isIterable(state.object_)) {\n              state.itr_ = state.object_[Symbol.iterator]();\n            } else if (state.object_.isObject) {\n              if (state.object_.class === 'Array') {\n                state.itr_ = Array.from(state.object_.properties);\n                state.itr_ = state.itr_.filter(v => v !== 'length');\n                state.itr_ = state.itr_[Symbol.iterator]();\n              } else if (state.object_.class === 'Map') {\n                state.itr_ = state.object_.properties['[[Entries]]'];\n                state.itr_ = new Map(state.itr_.map(kv => [kv.key, kv.value]));\n                state.itr_ = state.itr_[Symbol.iterator]();\n              } else if (state.object_.class === 'Set') {\n                state.itr_ = state.object_.properties['[[Entries]]'];\n                state.itr_ = state.itr_.map(kv => kv.value);\n                state.itr_ = state.itr_[Symbol.iterator]();\n              }\n            }\n          }\n          let value, next;\n          if (isIterable(state.itr_)) {\n            do {\n              next = state.itr_.next();\n              value = next.value;\n            } while (value && state.visited_[value] && !next.done);\n            if (value) {\n              state.visited_[value] = true;\n              if (!next.done) {\n                state.name_ = value;\n                break done;\n              }\n            }\n          }\n        }\n        state.object_ = this.getPrototype(state.object_);\n        state.itr_ = null;\n      } while (state.object_ !== null);\n      if (state.object_ === null) {\n        // Done, exit loop.\n        stack.pop();\n        return;\n      }\n    }\n    // Fourth, find the variable\n    if (!state.doneVariable_) {\n      state.doneVariable_ = true;\n      var left = node['left'];\n      if (left['type'] === 'VariableDeclaration') {\n        // Inline variable declaration: for (var x in y)\n        state.variable_ = [Interpreter.SCOPE_REFERENCE, left['declarations'][0]['id']['name']];\n      } else {\n        // Arbitrary left side: for (foo().bar in y)\n        state.variable_ = null;\n        var nextState = new MyState(left, state.scope);\n        nextState.components = true;\n        return nextState;\n      }\n    }\n    if (!state.variable_) {\n      state.variable_ = state.value;\n    }\n    // Fifth, set the variable.\n    if (!state.doneSetter_) {\n      state.doneSetter_ = true;\n      var value = state.name_;\n      var setter = this.setValue(state.variable_, value);\n      if (setter) {\n        return this.createSetter_(setter, state.variable_, value);\n      }\n    }\n    // Next step will be step three.\n    state.name_ = undefined;\n    // Reevaluate the variable since it could be a setter on the global object.\n    state.doneVariable_ = false;\n    state.doneSetter_ = false;\n    // Sixth and finally, execute the body if there was one.  this.\n    if (node['body']) {\n      return new MyState(node['body'], state.scope);\n    }\n  }\n\n  private stepForStatement(stack: MyState[], state: MyState, node: ESTree.Node) {\n    var mode = state.mode_ || 0;\n    if (mode === 0) {\n      state.mode_ = 1;\n      if (node['init']) {\n        return new MyState(node['init'], state.scope);\n      }\n    } else if (mode === 1) {\n      state.mode_ = 2;\n      if (node['test']) {\n        return new MyState(node['test'], state.scope);\n      }\n    } else if (mode === 2) {\n      state.mode_ = 3;\n      if (node['test'] && !state.value) {\n        // Done, exit loop.\n        stack.pop();\n      } else {\n        // Execute the body.\n        state.isLoop = true;\n        return new MyState(node['body'], state.scope);\n      }\n    } else if (mode === 3) {\n      state.mode_ = 1;\n      if (node['update']) {\n        return new MyState(node['update'], state.scope);\n      }\n    }\n  }\n\n  private stepFunctionDeclaration(stack: MyState[], state: MyState, node: ESTree.Node) {\n    // This was found and handled when the scope was populated.\n    stack.pop();\n  }\n\n  private stepFunctionExpression(stack: MyState[], state: MyState, node: ESTree.Node) {\n    stack.pop();\n    stack[stack.length - 1].value = this.createFunction(<ESTree.FunctionDeclaration>node, state.scope);\n  }\n\n  private stepIdentifier(stack: MyState[], state: MyState, node: ESTree.Node) {\n    stack.pop();\n    if (state.components) {\n      stack[stack.length - 1].value = [Interpreter.SCOPE_REFERENCE, node['name']];\n      return;\n    }\n    var value = this.getValueFromScope(node['name']);\n    // An identifier could be a getter if it's a property on the global object.\n    if (value && typeof value === 'object' && value.isGetter) {\n      // Clear the getter flag and call the getter function.\n      value.isGetter = false;\n      var scope = state.scope;\n      while (!this.hasProperty(scope, node['name'])) {\n        scope = scope.parentScope;\n      }\n      var func = /** @type {!Interpreter.Object} */ value;\n      return this.createGetter_(func, this.global);\n    }\n    stack[stack.length - 1].value = value;\n  }\n\n  private stepIfStatement(stack: MyState[], state: MyState, node: ESTree.Node) {\n    return this.stepConditionalExpression(stack, state, node);\n  }\n\n  private stepLabeledStatement(stack: MyState[], state: MyState, node: ESTree.Node) {\n    // No need to hit this node again on the way back up the stack.\n    stack.pop();\n    // Note that a statement might have multiple labels.\n    var labels = state.labels || [];\n    labels.push(node['label']['name']);\n    var nextState = new MyState(node['body'], state.scope);\n    nextState.labels = labels;\n    return nextState;\n  }\n\n  private stepLiteral(stack: MyState[], state: MyState, node: ESTree.Node) {\n    stack.pop();\n    var value = node['value'];\n    if (value instanceof RegExp) {\n      var pseudoRegexp = this.createObjectProto(this.REGEXP_PROTO);\n      this.populateRegExp(pseudoRegexp, value);\n      value = pseudoRegexp;\n    }\n    stack[stack.length - 1].value = value;\n  }\n\n  private stepLogicalExpression(stack: MyState[], state: MyState, node: ESTree.Node) {\n    if (node['operator'] !== '&&' && node['operator'] !== '||') {\n      throw SyntaxError('Unknown logical operator: ' + node['operator']);\n    }\n    if (!state.doneLeft_) {\n      state.doneLeft_ = true;\n      return new MyState(node['left'], state.scope);\n    }\n    if (!state.doneRight_) {\n      if ((node['operator'] === '&&' && !state.value) || (node['operator'] === '||' && state.value)) {\n        // Shortcut evaluation.\n        stack.pop();\n        stack[stack.length - 1].value = state.value;\n      } else {\n        state.doneRight_ = true;\n        return new MyState(node['right'], state.scope);\n      }\n    } else {\n      stack.pop();\n      stack[stack.length - 1].value = state.value;\n    }\n  }\n\n  private stepMemberExpression(stack: MyState[], state: MyState, node: ESTree.Node) {\n    if (!state.doneObject_) {\n      state.doneObject_ = true;\n      return new MyState(node['object'], state.scope);\n    }\n    var propName;\n    if (!node['computed']) {\n      state.object_ = state.value;\n      // obj.foo -- Just access 'foo' directly.\n      propName = node['property']['name'];\n    } else if (!state.doneProperty_) {\n      state.object_ = state.value;\n      // obj[foo] -- Compute value of 'foo'.\n      state.doneProperty_ = true;\n      return new MyState(node['property'], state.scope);\n    } else {\n      propName = state.value;\n    }\n    stack.pop();\n    if (state.components) {\n      stack[stack.length - 1].value = [state.object_, propName];\n    } else {\n      var value = this.getProperty(state.object_, propName);\n      if (value && typeof value === 'object' && value.isGetter) {\n        // Clear the getter flag and call the getter function.\n        value.isGetter = false;\n        var func = /** @type {!Interpreter.Object} */ value;\n        return this.createGetter_(func, state.object_);\n      }\n      stack[stack.length - 1].value = value;\n    }\n  }\n\n  private stepNewExpression(stack: MyState[], state: MyState, node: ESTree.Node) {\n    return this.stepCallExpression(stack, state, node);\n  }\n\n  private stepObjectExpression(stack: MyState[], state: MyState, node: ESTree.Node) {\n    var n = state.n_ || 0;\n    var property = node['properties'][n];\n    if (!state.object_) {\n      // First execution.\n      state.object_ = this.createObjectProto(this.OBJECT_PROTO);\n      state.properties_ = Object.create(null);\n    } else {\n      // Determine property name.\n      var key = <string>property['key'];\n      if (key['type'] === 'Identifier') {\n        var propName = key['name'];\n      } else if (key['type'] === 'Literal') {\n        var propName = key['value'];\n      } else {\n        throw SyntaxError('Unknown object structure: ' + key['type']);\n      }\n      // Set the property computed in the previous execution.\n      if (!state.properties_[propName]) {\n        // Create temp object to collect value, getter, and/or setter.\n        state.properties_[propName] = {};\n      }\n      state.properties_[propName][property['kind']] = state.value;\n      state.n_ = ++n;\n      property = node['properties'][n];\n    }\n    if (property) {\n      return new MyState(property['value'], state.scope);\n    }\n    for (var key in state.properties_) {\n      var kinds = state.properties_[key];\n      if ('get' in kinds || 'set' in kinds) {\n        // Set a property with a getter or setter.\n        var descriptor = {\n          configurable: true,\n          enumerable: true,\n          get: kinds['get'],\n          set: kinds['set'],\n        };\n        this.setProperty(state.object_, key, null, descriptor);\n      } else {\n        // Set a normal property with a value.\n        this.setProperty(state.object_, key, kinds['init']);\n      }\n    }\n    stack.pop();\n    stack[stack.length - 1].value = state.object_;\n  }\n\n  private stepProgram(stack: MyState[], state: MyState, node: ESTree.Node) {\n    var n = state.n_ || 0;\n    var expression = node['body'][n];\n    if (expression) {\n      state.done = false;\n      state.n_ = n + 1;\n      return new MyState(expression, state.scope);\n    }\n    state.done = true;\n    // Don't pop the stateStack.\n    // Leave the root scope on the tree in case the program is appended to.\n  }\n\n  private stepReturnStatement(stack: MyState[], state: MyState, node: ESTree.Node) {\n    if (node['argument'] && !state.done_) {\n      state.done_ = true;\n      return new MyState(node['argument'], state.scope);\n    }\n    var value = state.value;\n    var i = stack.length - 1;\n    state = stack[i];\n    while (state.node['type'] !== 'CallExpression' && state.node['type'] !== 'NewExpression') {\n      if (state.node['type'] !== 'TryStatement') {\n        stack.splice(i, 1);\n      }\n      i--;\n      if (i < 0) {\n        // Syntax error, do not allow this error to be trapped.\n        throw SyntaxError('Illegal return statement');\n      }\n      state = stack[i];\n    }\n    state.value = value;\n  }\n\n  private stepSequenceExpression(stack: MyState[], state: MyState, node: ESTree.Node) {\n    var n = state.n_ || 0;\n    var expression = node['expressions'][n];\n    if (expression) {\n      state.n_ = n + 1;\n      return new MyState(expression, state.scope);\n    }\n    stack.pop();\n    stack[stack.length - 1].value = state.value;\n  }\n\n  private stepSwitchStatement(stack: MyState[], state: MyState, node: ESTree.Node) {\n    if (!state.test_) {\n      state.test_ = 1;\n      return new MyState(node['discriminant'], state.scope);\n    }\n    if (state.test_ === 1) {\n      state.test_ = 2;\n      // Preserve switch value between case tests.\n      state.switchValue_ = state.value;\n    }\n\n    while (true) {\n      var index = state.index_ || 0;\n      var switchCase = node['cases'][index];\n      if (!state.matched_ && switchCase && !switchCase['test']) {\n        // Test on the default case is null.\n        // Bypass (but store) the default case, and get back to it later.\n        state.defaultCase_ = index;\n        state.index_ = index + 1;\n        continue;\n      }\n      if (!switchCase && !state.matched_ && state.defaultCase_) {\n        // Ran through all cases, no match.  Jump to the default.\n        state.matched_ = true;\n        state.index_ = state.defaultCase_;\n        continue;\n      }\n      if (switchCase) {\n        if (!state.matched_ && !state.tested_ && switchCase['test']) {\n          state.tested_ = true;\n          return new MyState(switchCase['test'], state.scope);\n        }\n        if (state.matched_ || state.value === state.switchValue_) {\n          state.matched_ = true;\n          var n = state.n_ || 0;\n          if (switchCase['consequent'][n]) {\n            state.isSwitch = true;\n            state.n_ = n + 1;\n            return new MyState(switchCase['consequent'][n], state.scope);\n          }\n        }\n        // Move on to next case.\n        state.tested_ = false;\n        state.n_ = 0;\n        state.index_ = index + 1;\n      } else {\n        stack.pop();\n        return;\n      }\n    }\n  }\n\n  private stepThisExpression(stack: MyState[], state: MyState, node: ESTree.Node) {\n    stack.pop();\n    stack[stack.length - 1].value = this.getValueFromScope('this');\n  }\n\n  private stepThrowStatement(stack: MyState[], state: MyState, node: ESTree.Node) {\n    if (!state.done_) {\n      state.done_ = true;\n      return new MyState(node['argument'], state.scope);\n    } else {\n      this.throwException(state.value);\n    }\n  }\n\n  private stepTryStatement(stack: MyState[], state: MyState, node: ESTree.Node) {\n    if (!state.doneBlock_) {\n      state.doneBlock_ = true;\n      return new MyState(node['block'], state.scope);\n    }\n    if (state.throwValue && !state.doneHandler_ && node['handler']) {\n      state.doneHandler_ = true;\n      var nextState = new MyState(node['handler'], state.scope);\n      nextState.throwValue = state.throwValue;\n      state.throwValue = null; // This error has been handled, don't rethrow.\n      return nextState;\n    }\n    if (!state.doneFinalizer_ && node['finalizer']) {\n      state.doneFinalizer_ = true;\n      return new MyState(node['finalizer'], state.scope);\n    }\n    if (state.throwValue) {\n      // There was no catch handler, or the catch/finally threw an error.\n      // Throw the error up to a higher try.\n      this.executeException(state.throwValue);\n    } else {\n      stack.pop();\n    }\n  }\n\n  private stepUnaryExpression(stack: MyState[], state: MyState, node: ESTree.Node) {\n    if (!state.done_) {\n      state.done_ = true;\n      var nextState = new MyState(node['argument'], state.scope);\n      nextState.components = node['operator'] === 'delete';\n      return nextState;\n    }\n    stack.pop();\n    var value = state.value;\n    if (node['operator'] === '-') {\n      value = -value;\n    } else if (node['operator'] === '+') {\n      value = +value;\n    } else if (node['operator'] === '!') {\n      value = !value;\n    } else if (node['operator'] === '~') {\n      value = ~value;\n    } else if (node['operator'] === 'delete') {\n      var result = true;\n      // If value is not an array, then it is a primitive, or some other value.\n      // If so, skip the delete and return true.\n      if (Array.isArray(value)) {\n        var obj = value[0];\n        if (obj === Interpreter.SCOPE_REFERENCE) {\n          // 'delete foo;' is the same as 'delete window.foo'.\n          obj = state.scope;\n        }\n        var name = String(value[1]);\n        try {\n          delete obj.properties[name];\n        } catch (e) {\n          if (state.scope.strict) {\n            this.throwException(this.TYPE_ERROR, \"Cannot delete property '\" + name + \"' of '\" + obj + \"'\");\n          } else {\n            result = false;\n          }\n        }\n      }\n      value = result;\n    } else if (node['operator'] === 'typeof') {\n      value = value && value.class === 'Function' ? 'function' : typeof value;\n    } else if (node['operator'] === 'void') {\n      value = undefined;\n    } else {\n      throw SyntaxError('Unknown unary operator: ' + node['operator']);\n    }\n    stack[stack.length - 1].value = value;\n  }\n\n  private stepUpdateExpression(stack: MyState[], state: MyState, node: ESTree.Node) {\n    if (!state.doneLeft_) {\n      state.doneLeft_ = true;\n      var nextState = new MyState(node['argument'], state.scope);\n      nextState.components = true;\n      return nextState;\n    }\n    if (!state.leftSide_) {\n      state.leftSide_ = state.value;\n    }\n    if (state.doneGetter_) {\n      state.leftValue_ = state.value;\n    }\n    if (!state.doneGetter_) {\n      var leftValue = this.getValue(state.leftSide_);\n      state.leftValue_ = leftValue;\n      if (leftValue && typeof leftValue === 'object' && leftValue.isGetter) {\n        // Clear the getter flag and call the getter function.\n        leftValue.isGetter = false;\n        state.doneGetter_ = true;\n        var func = /** @type {!Interpreter.Object} */ leftValue;\n        return this.createGetter_(func, state.leftSide_);\n      }\n    }\n    if (state.doneSetter_) {\n      // Return if setter function.\n      // Setter method on property has completed.\n      // Ignore its return value, and use the original set value instead.\n      stack.pop();\n      stack[stack.length - 1].value = state.doneSetter_;\n      return;\n    }\n    leftValue = Number(state.leftValue_);\n    var changeValue;\n    if (node['operator'] === '++') {\n      changeValue = leftValue + 1;\n    } else if (node['operator'] === '--') {\n      changeValue = leftValue - 1;\n    } else {\n      throw SyntaxError('Unknown update expression: ' + node['operator']);\n    }\n    var returnValue = node['prefix'] ? changeValue : leftValue;\n    var setter = this.setValue(state.leftSide_, changeValue);\n    if (setter) {\n      state.doneSetter_ = returnValue;\n      return this.createSetter_(setter, state.leftSide_, changeValue);\n    }\n    // Return if no setter function.\n    stack.pop();\n    stack[stack.length - 1].value = returnValue;\n  }\n\n  private stepVariableDeclaration(stack: MyState[], state: MyState, node: ESTree.Node) {\n    var declarations = node['declarations'];\n    var n = state.n_ || 0;\n    var declarationNode = declarations[n];\n    if (state.init_ && declarationNode) {\n      // This setValue call never needs to deal with calling a setter function.\n      // Note that this is setting the init value, not defining the variable.\n      // Variable definition is done when scope is populated.\n      this.setValueToScope(declarationNode['id']['name'], state.value);\n      state.init_ = false;\n      declarationNode = declarations[++n];\n    }\n    while (declarationNode) {\n      // Skip any declarations that are not initialized.  They have already\n      // been defined as undefined in populateScope_.\n      if (declarationNode['init']) {\n        state.n_ = n;\n        state.init_ = true;\n        return new MyState(declarationNode['init'], state.scope);\n      }\n      declarationNode = declarations[++n];\n    }\n    stack.pop();\n  }\n\n  private stepWithStatement(stack: MyState[], state: MyState, node: ESTree.Node) {\n    if (!state.doneObject_) {\n      state.doneObject_ = true;\n      return new MyState(node['object'], state.scope);\n    } else if (!state.doneBody_) {\n      state.doneBody_ = true;\n      var scope = this.createSpecialScope(state.scope, state.value);\n      return new MyState(node['body'], scope);\n    } else {\n      stack.pop();\n    }\n  }\n\n  private stepWhileStatement(stack: MyState[], state: MyState, node: ESTree.Node) {\n    return this.stepDoWhileStatement(stack, state, node);\n  }\n}\n\nconsole.log(Interpreter);\n","// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke and released under an MIT\n// license. The Unicode regexps (for identifiers and whitespace) were\n// taken from [Esprima](http://esprima.org) by Ariya Hidayat.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/marijnh/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/marijnh/acorn/issues\n//\n// This file defines the main parser interface. The library also comes\n// with a [error-tolerant parser][dammit] and an\n// [abstract syntax tree walker][walk], defined in other files.\n//\n// [dammit]: acorn_loose.js\n// [walk]: util/walk.js\n\n(function(root, mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") return mod(exports); // CommonJS\n  if (typeof define == \"function\" && define.amd) return define([\"exports\"], mod); // AMD\n  mod(root.acorn || (root.acorn = {})); // Plain browser env\n})(this, function(exports) {\n  \"use strict\";\n\n  exports.version = \"0.4.1\";\n\n  // The main exported interface (under `self.acorn` when in the\n  // browser) is a `parse` function that takes a code string and\n  // returns an abstract syntax tree as specified by [Mozilla parser\n  // API][api], with the caveat that the SpiderMonkey-specific syntax\n  // (`let`, `yield`, inline XML, etc) is not recognized.\n  //\n  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\n  var options, input, inputLen, sourceFile;\n\n  exports.parse = function(inpt, opts) {\n    input = String(inpt); inputLen = input.length;\n    setOptions(opts);\n    initTokenState();\n    return parseTopLevel(options.program);\n  };\n\n  // A second optional argument can be given to further configure\n  // the parser process. These options are recognized:\n\n  var defaultOptions = exports.defaultOptions = {\n    // `ecmaVersion` indicates the ECMAScript version to parse. Must\n    // be either 3 or 5. This\n    // influences support for strict mode, the set of reserved words, and\n    // support for getters and setter.\n    ecmaVersion: 5,\n    // Turn on `strictSemicolons` to prevent the parser from doing\n    // automatic semicolon insertion.\n    strictSemicolons: false,\n    // When `allowTrailingCommas` is false, the parser will not allow\n    // trailing commas in array and object literals.\n    allowTrailingCommas: true,\n    // By default, reserved words are not enforced. Enable\n    // `forbidReserved` to enforce them.\n    forbidReserved: false,\n    // When `locations` is on, `loc` properties holding objects with\n    // `start` and `end` properties in `{line, column}` form (with\n    // line being 1-based and column 0-based) will be attached to the\n    // nodes.\n    locations: false,\n    // A function can be passed as `onComment` option, which will\n    // cause Acorn to call that function with `(block, text, start,\n    // end)` parameters whenever a comment is skipped. `block` is a\n    // boolean indicating whether this is a block (`/* */`) comment,\n    // `text` is the content of the comment, and `start` and `end` are\n    // character offsets that denote the start and end of the comment.\n    // When the `locations` option is on, two more parameters are\n    // passed, the full `{line, column}` locations of the start and\n    // end of the comments.\n    onComment: null,\n    // Nodes have their start and end characters offsets recorded in\n    // `start` and `end` properties (directly on the node, rather than\n    // the `loc` object, which holds line/column data. To also add a\n    // [semi-standardized][range] `range` property holding a `[start,\n    // end]` array with the same numbers, set the `ranges` option to\n    // `true`.\n    //\n    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n    ranges: false,\n    // It is possible to parse multiple files into a single AST by\n    // passing the tree produced by parsing the first file as\n    // `program` option in subsequent parses. This will add the\n    // toplevel forms of the parsed file to the `Program` (top) node\n    // of an existing parse tree.\n    program: null,\n    // When `location` is on, you can pass this to record the source\n    // file in every node's `loc` object.\n    sourceFile: null,\n    // This value, if given, is stored in every node, whether\n    // `location` is on or off.\n    directSourceFile: null\n  };\n\n  function setOptions(opts) {\n    options = opts || {};\n    for (var opt in defaultOptions) if (!Object.prototype.hasOwnProperty.call(options, opt))\n      options[opt] = defaultOptions[opt];\n    sourceFile = options.sourceFile || null;\n  }\n\n  // The `getLineInfo` function is mostly useful when the\n  // `locations` option is off (for performance reasons) and you\n  // want to find the line/column position for a given character\n  // offset. `input` should be the code string that the offset refers\n  // into.\n\n  var getLineInfo = exports.getLineInfo = function(input, offset) {\n    for (var line = 1, cur = 0;;) {\n      lineBreak.lastIndex = cur;\n      var match = lineBreak.exec(input);\n      if (match && match.index < offset) {\n        ++line;\n        cur = match.index + match[0].length;\n      } else break;\n    }\n    return {line: line, column: offset - cur};\n  };\n\n  // Acorn is organized as a tokenizer and a recursive-descent parser.\n  // The `tokenize` export provides an interface to the tokenizer.\n  // Because the tokenizer is optimized for being efficiently used by\n  // the Acorn parser itself, this interface is somewhat crude and not\n  // very modular. Performing another parse or call to `tokenize` will\n  // reset the internal state, and invalidate existing tokenizers.\n\n  exports.tokenize = function(inpt, opts) {\n    input = String(inpt); inputLen = input.length;\n    setOptions(opts);\n    initTokenState();\n\n    var t = {};\n    function getToken(forceRegexp) {\n      readToken(forceRegexp);\n      t.start = tokStart; t.end = tokEnd;\n      t.startLoc = tokStartLoc; t.endLoc = tokEndLoc;\n      t.type = tokType; t.value = tokVal;\n      return t;\n    }\n    getToken.jumpTo = function(pos, reAllowed) {\n      tokPos = pos;\n      if (options.locations) {\n        tokCurLine = 1;\n        tokLineStart = lineBreak.lastIndex = 0;\n        var match;\n        while ((match = lineBreak.exec(input)) && match.index < pos) {\n          ++tokCurLine;\n          tokLineStart = match.index + match[0].length;\n        }\n      }\n      tokRegexpAllowed = reAllowed;\n      skipSpace();\n    };\n    return getToken;\n  };\n\n  // State is kept in (closure-)global variables. We already saw the\n  // `options`, `input`, and `inputLen` variables above.\n\n  // The current position of the tokenizer in the input.\n\n  var tokPos;\n\n  // The start and end offsets of the current token.\n\n  var tokStart, tokEnd;\n\n  // When `options.locations` is true, these hold objects\n  // containing the tokens start and end line/column pairs.\n\n  var tokStartLoc, tokEndLoc;\n\n  // The type and value of the current token. Token types are objects,\n  // named by variables against which they can be compared, and\n  // holding properties that describe them (indicating, for example,\n  // the precedence of an infix operator, and the original name of a\n  // keyword token). The kind of value that's held in `tokVal` depends\n  // on the type of the token. For literals, it is the literal value,\n  // for operators, the operator name, and so on.\n\n  var tokType, tokVal;\n\n  // Interal state for the tokenizer. To distinguish between division\n  // operators and regular expressions, it remembers whether the last\n  // token was one that is allowed to be followed by an expression.\n  // (If it is, a slash is probably a regexp, if it isn't it's a\n  // division operator. See the `parseStatement` function for a\n  // caveat.)\n\n  var tokRegexpAllowed;\n\n  // When `options.locations` is true, these are used to keep\n  // track of the current line, and know when a new line has been\n  // entered.\n\n  var tokCurLine, tokLineStart;\n\n  // These store the position of the previous token, which is useful\n  // when finishing a node and assigning its `end` position.\n\n  var lastStart, lastEnd, lastEndLoc;\n\n  // This is the parser's state. `inFunction` is used to reject\n  // `return` statements outside of functions, `labels` to verify that\n  // `break` and `continue` have somewhere to jump to, and `strict`\n  // indicates whether strict mode is on.\n\n  var inFunction, labels, strict;\n\n  // This function is used to raise exceptions on parse errors. It\n  // takes an offset integer (into the current `input`) to indicate\n  // the location of the error, attaches the position to the end\n  // of the error message, and then raises a `SyntaxError` with that\n  // message.\n\n  function raise(pos, message) {\n    var loc = getLineInfo(input, pos);\n    message += \" (\" + loc.line + \":\" + loc.column + \")\";\n    var err = new SyntaxError(message);\n    err.pos = pos; err.loc = loc; err.raisedAt = tokPos;\n    throw err;\n  }\n\n  // Reused empty array added for node fields that are always empty.\n\n  var empty = [];\n\n  // ## Token types\n\n  // The assignment of fine-grained, information-carrying type objects\n  // allows the tokenizer to store the information it has about a\n  // token in a way that is very cheap for the parser to look up.\n\n  // All token type variables start with an underscore, to make them\n  // easy to recognize.\n\n  // These are the general types. The `type` property is only used to\n  // make them recognizeable when debugging.\n\n  var _num = {type: \"num\"}, _regexp = {type: \"regexp\"}, _string = {type: \"string\"};\n  var _name = {type: \"name\"}, _eof = {type: \"eof\"};\n\n  // Keyword tokens. The `keyword` property (also used in keyword-like\n  // operators) indicates that the token originated from an\n  // identifier-like word, which is used when parsing property names.\n  //\n  // The `beforeExpr` property is used to disambiguate between regular\n  // expressions and divisions. It is set on all token types that can\n  // be followed by an expression (thus, a slash after them would be a\n  // regular expression).\n  //\n  // `isLoop` marks a keyword as starting a loop, which is important\n  // to know when parsing a label, in order to allow or disallow\n  // continue jumps to that label.\n\n  var _break = {keyword: \"break\"}, _case = {keyword: \"case\", beforeExpr: true}, _catch = {keyword: \"catch\"};\n  var _continue = {keyword: \"continue\"}, _debugger = {keyword: \"debugger\"}, _default = {keyword: \"default\"};\n  var _do = {keyword: \"do\", isLoop: true}, _else = {keyword: \"else\", beforeExpr: true};\n  var _finally = {keyword: \"finally\"}, _for = {keyword: \"for\", isLoop: true}, _function = {keyword: \"function\"};\n  var _if = {keyword: \"if\"}, _return = {keyword: \"return\", beforeExpr: true}, _switch = {keyword: \"switch\"};\n  var _throw = {keyword: \"throw\", beforeExpr: true}, _try = {keyword: \"try\"}, _var = {keyword: \"var\"};\n  var _while = {keyword: \"while\", isLoop: true}, _with = {keyword: \"with\"}, _new = {keyword: \"new\", beforeExpr: true};\n  var _this = {keyword: \"this\"};\n\n  // The keywords that denote values.\n\n  var _null = {keyword: \"null\", atomValue: null}, _true = {keyword: \"true\", atomValue: true};\n  var _false = {keyword: \"false\", atomValue: false};\n\n  // Some keywords are treated as regular operators. `in` sometimes\n  // (when parsing `for`) needs to be tested against specifically, so\n  // we assign a variable name to it for quick comparing.\n\n  var _in = {keyword: \"in\", binop: 7, beforeExpr: true};\n\n  // Map keyword names to token types.\n\n  var keywordTypes = {\"break\": _break, \"case\": _case, \"catch\": _catch,\n                      \"continue\": _continue, \"debugger\": _debugger, \"default\": _default,\n                      \"do\": _do, \"else\": _else, \"finally\": _finally, \"for\": _for,\n                      \"function\": _function, \"if\": _if, \"return\": _return, \"switch\": _switch,\n                      \"throw\": _throw, \"try\": _try, \"var\": _var, \"while\": _while, \"with\": _with,\n                      \"null\": _null, \"true\": _true, \"false\": _false, \"new\": _new, \"in\": _in,\n                      \"instanceof\": {keyword: \"instanceof\", binop: 7, beforeExpr: true}, \"this\": _this,\n                      \"typeof\": {keyword: \"typeof\", prefix: true, beforeExpr: true},\n                      \"void\": {keyword: \"void\", prefix: true, beforeExpr: true},\n                      \"delete\": {keyword: \"delete\", prefix: true, beforeExpr: true}};\n\n  // Punctuation token types. Again, the `type` property is purely for debugging.\n\n  var _bracketL = {type: \"[\", beforeExpr: true}, _bracketR = {type: \"]\"}, _braceL = {type: \"{\", beforeExpr: true};\n  var _braceR = {type: \"}\"}, _parenL = {type: \"(\", beforeExpr: true}, _parenR = {type: \")\"};\n  var _comma = {type: \",\", beforeExpr: true}, _semi = {type: \";\", beforeExpr: true};\n  var _colon = {type: \":\", beforeExpr: true}, _dot = {type: \".\"}, _question = {type: \"?\", beforeExpr: true};\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator. `isUpdate` specifies that the node produced by\n  // the operator should be of type UpdateExpression rather than\n  // simply UnaryExpression (`++` and `--`).\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  var _slash = {binop: 10, beforeExpr: true}, _eq = {isAssign: true, beforeExpr: true};\n  var _assign = {isAssign: true, beforeExpr: true};\n  var _incDec = {postfix: true, prefix: true, isUpdate: true}, _prefix = {prefix: true, beforeExpr: true};\n  var _logicalOR = {binop: 1, beforeExpr: true};\n  var _logicalAND = {binop: 2, beforeExpr: true};\n  var _bitwiseOR = {binop: 3, beforeExpr: true};\n  var _bitwiseXOR = {binop: 4, beforeExpr: true};\n  var _bitwiseAND = {binop: 5, beforeExpr: true};\n  var _equality = {binop: 6, beforeExpr: true};\n  var _relational = {binop: 7, beforeExpr: true};\n  var _bitShift = {binop: 8, beforeExpr: true};\n  var _plusMin = {binop: 9, prefix: true, beforeExpr: true};\n  var _multiplyModulo = {binop: 10, beforeExpr: true};\n\n  // Provide access to the token types for external users of the\n  // tokenizer.\n\n  exports.tokTypes = {bracketL: _bracketL, bracketR: _bracketR, braceL: _braceL, braceR: _braceR,\n                      parenL: _parenL, parenR: _parenR, comma: _comma, semi: _semi, colon: _colon,\n                      dot: _dot, question: _question, slash: _slash, eq: _eq, name: _name, eof: _eof,\n                      num: _num, regexp: _regexp, string: _string};\n  for (var kw in keywordTypes) exports.tokTypes[\"_\" + kw] = keywordTypes[kw];\n\n  // This is a trick taken from Esprima. It turns out that, on\n  // non-Chrome browsers, to check whether a string is in a set, a\n  // predicate containing a big ugly `switch` statement is faster than\n  // a regular expression, and on Chrome the two are about on par.\n  // This function uses `eval` (non-lexical) to produce such a\n  // predicate from a space-separated string of words.\n  //\n  // It starts by sorting the words by length.\n\n  function makePredicate(words) {\n    words = words.split(\" \");\n    var f = \"\", cats = [];\n    out: for (var i = 0; i < words.length; ++i) {\n      for (var j = 0; j < cats.length; ++j)\n        if (cats[j][0].length == words[i].length) {\n          cats[j].push(words[i]);\n          continue out;\n        }\n      cats.push([words[i]]);\n    }\n    function compareTo(arr) {\n      if (arr.length == 1) return f += \"return str === \" + JSON.stringify(arr[0]) + \";\";\n      f += \"switch(str){\";\n      for (var i = 0; i < arr.length; ++i) f += \"case \" + JSON.stringify(arr[i]) + \":\";\n      f += \"return true}return false;\";\n    }\n\n    // When there are more than three length categories, an outer\n    // switch first dispatches on the lengths, to save on comparisons.\n\n    if (cats.length > 3) {\n      cats.sort(function(a, b) {return b.length - a.length;});\n      f += \"switch(str.length){\";\n      for (var i = 0; i < cats.length; ++i) {\n        var cat = cats[i];\n        f += \"case \" + cat[0].length + \":\";\n        compareTo(cat);\n      }\n      f += \"}\";\n\n    // Otherwise, simply generate a flat `switch` statement.\n\n    } else {\n      compareTo(words);\n    }\n    return new Function(\"str\", f);\n  }\n\n  // The ECMAScript 3 reserved word list.\n\n  var isReservedWord3 = makePredicate(\"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\");\n\n  // ECMAScript 5 reserved words.\n\n  var isReservedWord5 = makePredicate(\"class enum extends super const export import\");\n\n  // The additional reserved words in strict mode.\n\n  var isStrictReservedWord = makePredicate(\"implements interface let package private protected public static yield\");\n\n  // The forbidden variable names in strict mode.\n\n  var isStrictBadIdWord = makePredicate(\"eval arguments\");\n\n  // And the keywords.\n\n  var isKeyword = makePredicate(\"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\");\n\n  // ## Character categories\n\n  // Big ugly regular expressions that match characters in the\n  // whitespace, identifier, and identifier-start categories. These\n  // are only applied when a character is found to actually have a\n  // code point above 128.\n\n  var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n  var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n  var nonASCIIidentifierChars = \"\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n  var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n  var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\n  // Whether a single character denotes a newline.\n\n  var newline = /[\\n\\r\\u2028\\u2029]/;\n\n  // Matches a whole line break (where CRLF is considered a single\n  // line break). Used to count lines.\n\n  var lineBreak = /\\r\\n|[\\n\\r\\u2028\\u2029]/g;\n\n  // Test whether a given character code starts an identifier.\n\n  var isIdentifierStart = exports.isIdentifierStart = function(code) {\n    if (code < 65) return code === 36;\n    if (code < 91) return true;\n    if (code < 97) return code === 95;\n    if (code < 123)return true;\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  };\n\n  // Test whether a given character is part of an identifier.\n\n  var isIdentifierChar = exports.isIdentifierChar = function(code) {\n    if (code < 48) return code === 36;\n    if (code < 58) return true;\n    if (code < 65) return false;\n    if (code < 91) return true;\n    if (code < 97) return code === 95;\n    if (code < 123)return true;\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  };\n\n  // ## Tokenizer\n\n  // These are used when `options.locations` is on, for the\n  // `tokStartLoc` and `tokEndLoc` properties.\n\n  function line_loc_t() {\n    this.line = tokCurLine;\n    this.column = tokPos - tokLineStart;\n  }\n\n  // Reset the token state. Used at the start of a parse.\n\n  function initTokenState() {\n    tokCurLine = 1;\n    tokPos = tokLineStart = 0;\n    tokRegexpAllowed = true;\n    skipSpace();\n  }\n\n  // Called at the end of every token. Sets `tokEnd`, `tokVal`, and\n  // `tokRegexpAllowed`, and skips the space after the token, so that\n  // the next one's `tokStart` will point at the right position.\n\n  function finishToken(type, val) {\n    tokEnd = tokPos;\n    if (options.locations) tokEndLoc = new line_loc_t;\n    tokType = type;\n    skipSpace();\n    tokVal = val;\n    tokRegexpAllowed = type.beforeExpr;\n  }\n\n  function skipBlockComment() {\n    var startLoc = options.onComment && options.locations && new line_loc_t;\n    var start = tokPos, end = input.indexOf(\"*/\", tokPos += 2);\n    if (end === -1) raise(tokPos - 2, \"Unterminated comment\");\n    tokPos = end + 2;\n    if (options.locations) {\n      lineBreak.lastIndex = start;\n      var match;\n      while ((match = lineBreak.exec(input)) && match.index < tokPos) {\n        ++tokCurLine;\n        tokLineStart = match.index + match[0].length;\n      }\n    }\n    if (options.onComment)\n      options.onComment(true, input.slice(start + 2, end), start, tokPos,\n                        startLoc, options.locations && new line_loc_t);\n  }\n\n  function skipLineComment() {\n    var start = tokPos;\n    var startLoc = options.onComment && options.locations && new line_loc_t;\n    var ch = input.charCodeAt(tokPos+=2);\n    while (tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {\n      ++tokPos;\n      ch = input.charCodeAt(tokPos);\n    }\n    if (options.onComment)\n      options.onComment(false, input.slice(start + 2, tokPos), start, tokPos,\n                        startLoc, options.locations && new line_loc_t);\n  }\n\n  // Called at the start of the parse and after every token. Skips\n  // whitespace and comments, and.\n\n  function skipSpace() {\n    while (tokPos < inputLen) {\n      var ch = input.charCodeAt(tokPos);\n      if (ch === 32) { // ' '\n        ++tokPos;\n      } else if (ch === 13) {\n        ++tokPos;\n        var next = input.charCodeAt(tokPos);\n        if (next === 10) {\n          ++tokPos;\n        }\n        if (options.locations) {\n          ++tokCurLine;\n          tokLineStart = tokPos;\n        }\n      } else if (ch === 10 || ch === 8232 || ch === 8233) {\n        ++tokPos;\n        if (options.locations) {\n          ++tokCurLine;\n          tokLineStart = tokPos;\n        }\n      } else if (ch > 8 && ch < 14) {\n        ++tokPos;\n      } else if (ch === 47) { // '/'\n        var next = input.charCodeAt(tokPos + 1);\n        if (next === 42) { // '*'\n          skipBlockComment();\n        } else if (next === 47) { // '/'\n          skipLineComment();\n        } else break;\n      } else if (ch === 160) { // '\\xa0'\n        ++tokPos;\n      } else if (ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n        ++tokPos;\n      } else {\n        break;\n      }\n    }\n  }\n\n  // ### Token reading\n\n  // This is the function that is called to fetch the next token. It\n  // is somewhat obscure, because it works in character codes rather\n  // than characters, and because operator parsing has been inlined\n  // into it.\n  //\n  // All in the name of speed.\n  //\n  // The `forceRegexp` parameter is used in the one case where the\n  // `tokRegexpAllowed` trick does not work. See `parseStatement`.\n\n  function readToken_dot() {\n    var next = input.charCodeAt(tokPos + 1);\n    if (next >= 48 && next <= 57) return readNumber(true);\n    ++tokPos;\n    return finishToken(_dot);\n  }\n\n  function readToken_slash() { // '/'\n    var next = input.charCodeAt(tokPos + 1);\n    if (tokRegexpAllowed) {++tokPos; return readRegexp();}\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(_slash, 1);\n  }\n\n  function readToken_mult_modulo() { // '%*'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(_multiplyModulo, 1);\n  }\n\n  function readToken_pipe_amp(code) { // '|&'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === code) return finishOp(code === 124 ? _logicalOR : _logicalAND, 2);\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(code === 124 ? _bitwiseOR : _bitwiseAND, 1);\n  }\n\n  function readToken_caret() { // '^'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(_bitwiseXOR, 1);\n  }\n\n  function readToken_plus_min(code) { // '+-'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === code) {\n      if (next == 45 && input.charCodeAt(tokPos + 2) == 62 &&\n          newline.test(input.slice(lastEnd, tokPos))) {\n        // A `-->` line comment\n        tokPos += 3;\n        skipLineComment();\n        skipSpace();\n        return readToken();\n      }\n      return finishOp(_incDec, 2);\n    }\n    if (next === 61) return finishOp(_assign, 2);\n    return finishOp(_plusMin, 1);\n  }\n\n  function readToken_lt_gt(code) { // '<>'\n    var next = input.charCodeAt(tokPos + 1);\n    var size = 1;\n    if (next === code) {\n      size = code === 62 && input.charCodeAt(tokPos + 2) === 62 ? 3 : 2;\n      if (input.charCodeAt(tokPos + size) === 61) return finishOp(_assign, size + 1);\n      return finishOp(_bitShift, size);\n    }\n    if (next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 &&\n        input.charCodeAt(tokPos + 3) == 45) {\n      // `<!--`, an XML-style comment that should be interpreted as a line comment\n      tokPos += 4;\n      skipLineComment();\n      skipSpace();\n      return readToken();\n    }\n    if (next === 61)\n      size = input.charCodeAt(tokPos + 2) === 61 ? 3 : 2;\n    return finishOp(_relational, size);\n  }\n\n  function readToken_eq_excl(code) { // '=!'\n    var next = input.charCodeAt(tokPos + 1);\n    if (next === 61) return finishOp(_equality, input.charCodeAt(tokPos + 2) === 61 ? 3 : 2);\n    return finishOp(code === 61 ? _eq : _prefix, 1);\n  }\n\n  function getTokenFromCode(code) {\n    switch(code) {\n      // The interpretation of a dot depends on whether it is followed\n      // by a digit.\n    case 46: // '.'\n      return readToken_dot();\n\n      // Punctuation tokens.\n    case 40: ++tokPos; return finishToken(_parenL);\n    case 41: ++tokPos; return finishToken(_parenR);\n    case 59: ++tokPos; return finishToken(_semi);\n    case 44: ++tokPos; return finishToken(_comma);\n    case 91: ++tokPos; return finishToken(_bracketL);\n    case 93: ++tokPos; return finishToken(_bracketR);\n    case 123: ++tokPos; return finishToken(_braceL);\n    case 125: ++tokPos; return finishToken(_braceR);\n    case 58: ++tokPos; return finishToken(_colon);\n    case 63: ++tokPos; return finishToken(_question);\n\n      // '0x' is a hexadecimal number.\n    case 48: // '0'\n      var next = input.charCodeAt(tokPos + 1);\n      if (next === 120 || next === 88) return readHexNumber();\n      // Anything else beginning with a digit is an integer, octal\n      // number, or float.\n    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n      return readNumber(false);\n\n      // Quotes produce strings.\n    case 34: case 39: // '\"', \"'\"\n      return readString(code);\n\n    // Operators are parsed inline in tiny state machines. '=' (61) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n    case 47: // '/'\n      return readToken_slash(code);\n\n    case 37: case 42: // '%*'\n      return readToken_mult_modulo();\n\n    case 124: case 38: // '|&'\n      return readToken_pipe_amp(code);\n\n    case 94: // '^'\n      return readToken_caret();\n\n    case 43: case 45: // '+-'\n      return readToken_plus_min(code);\n\n    case 60: case 62: // '<>'\n      return readToken_lt_gt(code);\n\n    case 61: case 33: // '=!'\n      return readToken_eq_excl(code);\n\n    case 126: // '~'\n      return finishOp(_prefix, 1);\n    }\n\n    return false;\n  }\n\n  function readToken(forceRegexp) {\n    if (!forceRegexp) tokStart = tokPos;\n    else tokPos = tokStart + 1;\n    if (options.locations) tokStartLoc = new line_loc_t;\n    if (forceRegexp) return readRegexp();\n    if (tokPos >= inputLen) return finishToken(_eof);\n\n    var code = input.charCodeAt(tokPos);\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\n    // identifiers, so '\\' also dispatches to that.\n    if (isIdentifierStart(code) || code === 92 /* '\\' */) return readWord();\n\n    var tok = getTokenFromCode(code);\n\n    if (tok === false) {\n      // If we are here, we either found a non-ASCII identifier\n      // character, or something that's entirely disallowed.\n      var ch = String.fromCharCode(code);\n      if (ch === \"\\\\\" || nonASCIIidentifierStart.test(ch)) return readWord();\n      raise(tokPos, \"Unexpected character '\" + ch + \"'\");\n    }\n    return tok;\n  }\n\n  function finishOp(type, size) {\n    var str = input.slice(tokPos, tokPos + size);\n    tokPos += size;\n    finishToken(type, str);\n  }\n\n  // Parse a regular expression. Some context-awareness is necessary,\n  // since a '/' inside a '[]' set does not end the expression.\n\n  function readRegexp() {\n    var content = \"\", escaped, inClass, start = tokPos;\n    for (;;) {\n      if (tokPos >= inputLen) raise(start, \"Unterminated regular expression\");\n      var ch = input.charAt(tokPos);\n      if (newline.test(ch)) raise(start, \"Unterminated regular expression\");\n      if (!escaped) {\n        if (ch === \"[\") inClass = true;\n        else if (ch === \"]\" && inClass) inClass = false;\n        else if (ch === \"/\" && !inClass) break;\n        escaped = ch === \"\\\\\";\n      } else escaped = false;\n      ++tokPos;\n    }\n    var content = input.slice(start, tokPos);\n    ++tokPos;\n    // Need to use `readWord1` because '\\uXXXX' sequences are allowed\n    // here (don't ask).\n    var mods = readWord1();\n    if (mods && !/^[gmsiy]*$/.test(mods)) raise(start, \"Invalid regexp flag\");\n    return finishToken(_regexp, new RegExp(content, mods));\n  }\n\n  // Read an integer in the given radix. Return null if zero digits\n  // were read, the integer value otherwise. When `len` is given, this\n  // will return `null` unless the integer has exactly `len` digits.\n\n  function readInt(radix, len) {\n    var start = tokPos, total = 0;\n    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      var code = input.charCodeAt(tokPos), val;\n      if (code >= 97) val = code - 97 + 10; // a\n      else if (code >= 65) val = code - 65 + 10; // A\n      else if (code >= 48 && code <= 57) val = code - 48; // 0-9\n      else val = Infinity;\n      if (val >= radix) break;\n      ++tokPos;\n      total = total * radix + val;\n    }\n    if (tokPos === start || len != null && tokPos - start !== len) return null;\n\n    return total;\n  }\n\n  function readHexNumber() {\n    tokPos += 2; // 0x\n    var val = readInt(16);\n    if (val == null) raise(tokStart + 2, \"Expected hexadecimal number\");\n    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\n    return finishToken(_num, val);\n  }\n\n  // Read an integer, octal integer, or floating-point number.\n\n  function readNumber(startsWithDot) {\n    var start = tokPos, isFloat = false, octal = input.charCodeAt(tokPos) === 48;\n    if (!startsWithDot && readInt(10) === null) raise(start, \"Invalid number\");\n    if (input.charCodeAt(tokPos) === 46) {\n      ++tokPos;\n      readInt(10);\n      isFloat = true;\n    }\n    var next = input.charCodeAt(tokPos);\n    if (next === 69 || next === 101) { // 'eE'\n      next = input.charCodeAt(++tokPos);\n      if (next === 43 || next === 45) ++tokPos; // '+-'\n      if (readInt(10) === null) raise(start, \"Invalid number\");\n      isFloat = true;\n    }\n    if (isIdentifierStart(input.charCodeAt(tokPos))) raise(tokPos, \"Identifier directly after number\");\n\n    var str = input.slice(start, tokPos), val;\n    if (isFloat) val = parseFloat(str);\n    else if (!octal || str.length === 1) val = parseInt(str, 10);\n    else if (/[89]/.test(str) || strict) raise(start, \"Invalid number\");\n    else val = parseInt(str, 8);\n    return finishToken(_num, val);\n  }\n\n  // Read a string value, interpreting backslash-escapes.\n\n  function readString(quote) {\n    tokPos++;\n    var out = \"\";\n    for (;;) {\n      if (tokPos >= inputLen) raise(tokStart, \"Unterminated string constant\");\n      var ch = input.charCodeAt(tokPos);\n      if (ch === quote) {\n        ++tokPos;\n        return finishToken(_string, out);\n      }\n      if (ch === 92) { // '\\'\n        ch = input.charCodeAt(++tokPos);\n        var octal = /^[0-7]+/.exec(input.slice(tokPos, tokPos + 3));\n        if (octal) octal = octal[0];\n        while (octal && parseInt(octal, 8) > 255) octal = octal.slice(0, -1);\n        if (octal === \"0\") octal = null;\n        ++tokPos;\n        if (octal) {\n          if (strict) raise(tokPos - 2, \"Octal literal in strict mode\");\n          out += String.fromCharCode(parseInt(octal, 8));\n          tokPos += octal.length - 1;\n        } else {\n          switch (ch) {\n          case 110: out += \"\\n\"; break; // 'n' -> '\\n'\n          case 114: out += \"\\r\"; break; // 'r' -> '\\r'\n          case 120: out += String.fromCharCode(readHexChar(2)); break; // 'x'\n          case 117: out += String.fromCharCode(readHexChar(4)); break; // 'u'\n          case 85: out += String.fromCharCode(readHexChar(8)); break; // 'U'\n          case 116: out += \"\\t\"; break; // 't' -> '\\t'\n          case 98: out += \"\\b\"; break; // 'b' -> '\\b'\n          case 118: out += \"\\u000b\"; break; // 'v' -> '\\u000b'\n          case 102: out += \"\\f\"; break; // 'f' -> '\\f'\n          case 48: out += \"\\0\"; break; // 0 -> '\\0'\n          case 13: if (input.charCodeAt(tokPos) === 10) ++tokPos; // '\\r\\n'\n          case 10: // ' \\n'\n            if (options.locations) { tokLineStart = tokPos; ++tokCurLine; }\n            break;\n          default: out += String.fromCharCode(ch); break;\n          }\n        }\n      } else {\n        if (ch === 13 || ch === 10 || ch === 8232 || ch === 8233) raise(tokStart, \"Unterminated string constant\");\n        out += String.fromCharCode(ch); // '\\'\n        ++tokPos;\n      }\n    }\n  }\n\n  // Used to read character escape sequences ('\\x', '\\u', '\\U').\n\n  function readHexChar(len) {\n    var n = readInt(16, len);\n    if (n === null) raise(tokStart, \"Bad character escape sequence\");\n    return n;\n  }\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n\n  var containsEsc;\n\n  // Read an identifier, and return it as a string. Sets `containsEsc`\n  // to whether the word contained a '\\u' escape.\n  //\n  // Only builds up the word character-by-character when it actually\n  // containeds an escape, as a micro-optimization.\n\n  function readWord1() {\n    containsEsc = false;\n    var word, first = true, start = tokPos;\n    for (;;) {\n      var ch = input.charCodeAt(tokPos);\n      if (isIdentifierChar(ch)) {\n        if (containsEsc) word += input.charAt(tokPos);\n        ++tokPos;\n      } else if (ch === 92) { // \"\\\"\n        if (!containsEsc) word = input.slice(start, tokPos);\n        containsEsc = true;\n        if (input.charCodeAt(++tokPos) != 117) // \"u\"\n          raise(tokPos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n        ++tokPos;\n        var esc = readHexChar(4);\n        var escStr = String.fromCharCode(esc);\n        if (!escStr) raise(tokPos - 1, \"Invalid Unicode escape\");\n        if (!(first ? isIdentifierStart(esc) : isIdentifierChar(esc)))\n          raise(tokPos - 4, \"Invalid Unicode escape\");\n        word += escStr;\n      } else {\n        break;\n      }\n      first = false;\n    }\n    return containsEsc ? word : input.slice(start, tokPos);\n  }\n\n  // Read an identifier or keyword token. Will check for reserved\n  // words when necessary.\n\n  function readWord() {\n    var word = readWord1();\n    var type = _name;\n    if (!containsEsc) {\n      if (isKeyword(word)) type = keywordTypes[word];\n      else if (options.forbidReserved &&\n               (options.ecmaVersion === 3 ? isReservedWord3 : isReservedWord5)(word) ||\n               strict && isStrictReservedWord(word))\n        raise(tokStart, \"The keyword '\" + word + \"' is reserved\");\n    }\n    return finishToken(type, word);\n  }\n\n  // ## Parser\n\n  // A recursive descent parser operates by defining functions for all\n  // syntactic elements, and recursively calling those, each function\n  // advancing the input stream and returning an AST node. Precedence\n  // of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n  // instead of `(!x)[1]` is handled by the fact that the parser\n  // function that parses unary prefix operators is called first, and\n  // in turn calls the function that parses `[]` subscripts  that\n  // way, it'll receive the node for `x[1]` already parsed, and wraps\n  // *that* in the unary operator node.\n  //\n  // Acorn uses an [operator precedence parser][opp] to handle binary\n  // operator precedence, because it is much more compact than using\n  // the technique outlined above, which uses different, nesting\n  // functions to specify precedence, for all of the ten binary\n  // precedence levels that JavaScript defines.\n  //\n  // [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\n  // ### Parser utilities\n\n  // Continue to the next token.\n\n  function next() {\n    lastStart = tokStart;\n    lastEnd = tokEnd;\n    lastEndLoc = tokEndLoc;\n    readToken();\n  }\n\n  // Enter strict mode. Re-reads the next token to please pedantic\n  // tests (\"use strict\"; 010; -- should fail).\n\n  function setStrict(strct) {\n    strict = strct;\n    tokPos = lastEnd;\n    if (options.locations) {\n      while (tokPos < tokLineStart) {\n        tokLineStart = input.lastIndexOf(\"\\n\", tokLineStart - 2) + 1;\n        --tokCurLine;\n      }\n    }\n    skipSpace();\n    readToken();\n  }\n\n  // Start an AST node, attaching a start offset.\n\n  function node_t() {\n    this.type = null;\n    this.start = tokStart;\n    this.end = null;\n  }\n\n  function node_loc_t() {\n    this.start = tokStartLoc;\n    this.end = null;\n    if (sourceFile !== null) this.source = sourceFile;\n  }\n\n  function startNode() {\n    var node = new node_t();\n    if (options.locations)\n      node.loc = new node_loc_t();\n    if (options.directSourceFile)\n      node.sourceFile = options.directSourceFile;\n    if (options.ranges)\n      node.range = [tokStart, 0];\n    return node;\n  }\n\n  // Start a node whose start offset information should be based on\n  // the start of another node. For example, a binary operator node is\n  // only started after its left-hand side has already been parsed.\n\n  function startNodeFrom(other) {\n    var node = new node_t();\n    node.start = other.start;\n    if (options.locations) {\n      node.loc = new node_loc_t();\n      node.loc.start = other.loc.start;\n    }\n    if (options.ranges)\n      node.range = [other.range[0], 0];\n\n    return node;\n  }\n\n  // Finish an AST node, adding `type` and `end` properties.\n\n  function finishNode(node, type) {\n    node.type = type;\n    node.end = lastEnd;\n    if (options.locations)\n      node.loc.end = lastEndLoc;\n    if (options.ranges)\n      node.range[1] = lastEnd;\n    return node;\n  }\n\n  // Test whether a statement node is the string literal `\"use strict\"`.\n\n  function isUseStrict(stmt) {\n    return options.ecmaVersion >= 5 && stmt.type === \"ExpressionStatement\" &&\n      stmt.expression.type === \"Literal\" && stmt.expression.value === \"use strict\";\n  }\n\n  // Predicate that tests whether the next token is of the given\n  // type, and if yes, consumes it as a side effect.\n\n  function eat(type) {\n    if (tokType === type) {\n      next();\n      return true;\n    }\n  }\n\n  // Test whether a semicolon can be inserted at the current position.\n\n  function canInsertSemicolon() {\n    return !options.strictSemicolons &&\n      (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd, tokStart)));\n  }\n\n  // Consume a semicolon, or, failing that, see if we are allowed to\n  // pretend that there is a semicolon at this position.\n\n  function semicolon() {\n    if (!eat(_semi) && !canInsertSemicolon()) unexpected();\n  }\n\n  // Expect a token of a given type. If found, consume it, otherwise,\n  // raise an unexpected token error.\n\n  function expect(type) {\n    if (tokType === type) next();\n    else unexpected();\n  }\n\n  // Raise an unexpected token error.\n\n  function unexpected() {\n    raise(tokStart, \"Unexpected token\");\n  }\n\n  // Verify that a node is an lval  something that can be assigned\n  // to.\n\n  function checkLVal(expr) {\n    if (expr.type !== \"Identifier\" && expr.type !== \"MemberExpression\")\n      raise(expr.start, \"Assigning to rvalue\");\n    if (strict && expr.type === \"Identifier\" && isStrictBadIdWord(expr.name))\n      raise(expr.start, \"Assigning to \" + expr.name + \" in strict mode\");\n  }\n\n  // ### Statement parsing\n\n  // Parse a program. Initializes the parser, reads any number of\n  // statements, and wraps them in a Program node.  Optionally takes a\n  // `program` argument.  If present, the statements will be appended\n  // to its body instead of creating a new node.\n\n  function parseTopLevel(program) {\n    lastStart = lastEnd = tokPos;\n    if (options.locations) lastEndLoc = new line_loc_t;\n    inFunction = strict = null;\n    labels = [];\n    readToken();\n\n    var node = program || startNode(), first = true;\n    if (!program) node.body = [];\n    while (tokType !== _eof) {\n      var stmt = parseStatement();\n      node.body.push(stmt);\n      if (first && isUseStrict(stmt)) setStrict(true);\n      first = false;\n    }\n    return finishNode(node, \"Program\");\n  }\n\n  var loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\n\n  // Parse a single statement.\n  //\n  // If expecting a statement and finding a slash operator, parse a\n  // regular expression literal. This is to handle cases like\n  // `if (foo) /blah/.exec(foo);`, where looking at the previous token\n  // does not help.\n\n  function parseStatement() {\n    if (tokType === _slash || tokType === _assign && tokVal == \"/=\")\n      readToken(true);\n\n    var starttype = tokType, node = startNode();\n\n    // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n\n    switch (starttype) {\n    case _break: case _continue:\n      next();\n      var isBreak = starttype === _break;\n      if (eat(_semi) || canInsertSemicolon()) node.label = null;\n      else if (tokType !== _name) unexpected();\n      else {\n        node.label = parseIdent();\n        semicolon();\n      }\n\n      // Verify that there is an actual destination to break or\n      // continue to.\n      for (var i = 0; i < labels.length; ++i) {\n        var lab = labels[i];\n        if (node.label == null || lab.name === node.label.name) {\n          if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n          if (node.label && isBreak) break;\n        }\n      }\n      if (i === labels.length) raise(node.start, \"Unsyntactic \" + starttype.keyword);\n      return finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n\n    case _debugger:\n      next();\n      semicolon();\n      return finishNode(node, \"DebuggerStatement\");\n\n    case _do:\n      next();\n      labels.push(loopLabel);\n      node.body = parseStatement();\n      labels.pop();\n      expect(_while);\n      node.test = parseParenExpression();\n      semicolon();\n      return finishNode(node, \"DoWhileStatement\");\n\n      // Disambiguating between a `for` and a `for`/`in` loop is\n      // non-trivial. Basically, we have to parse the init `var`\n      // statement or expression, disallowing the `in` operator (see\n      // the second parameter to `parseExpression`), and then check\n      // whether the next token is `in`. When there is no init part\n      // (semicolon immediately after the opening parenthesis), it is\n      // a regular `for` loop.\n\n    case _for:\n      next();\n      labels.push(loopLabel);\n      expect(_parenL);\n      if (tokType === _semi) return parseFor(node, null);\n      if (tokType === _var) {\n        var init = startNode();\n        next();\n        parseVar(init, true);\n        finishNode(init, \"VariableDeclaration\");\n        if (init.declarations.length === 1 && eat(_in))\n          return parseForIn(node, init);\n        return parseFor(node, init);\n      }\n      var init = parseExpression(false, true);\n      if (eat(_in)) {checkLVal(init); return parseForIn(node, init);}\n      return parseFor(node, init);\n\n    case _function:\n      next();\n      return parseFunction(node, true);\n\n    case _if:\n      next();\n      node.test = parseParenExpression();\n      node.consequent = parseStatement();\n      node.alternate = eat(_else) ? parseStatement() : null;\n      return finishNode(node, \"IfStatement\");\n\n    case _return:\n      if (!inFunction) raise(tokStart, \"'return' outside of function\");\n      next();\n\n      // In `return` (and `break`/`continue`), the keywords with\n      // optional arguments, we eagerly look for a semicolon or the\n      // possibility to insert one.\n\n      if (eat(_semi) || canInsertSemicolon()) node.argument = null;\n      else { node.argument = parseExpression(); semicolon(); }\n      return finishNode(node, \"ReturnStatement\");\n\n    case _switch:\n      next();\n      node.discriminant = parseParenExpression();\n      node.cases = [];\n      expect(_braceL);\n      labels.push(switchLabel);\n\n      // Statements under must be grouped (by label) in SwitchCase\n      // nodes. `cur` is used to keep the node that we are currently\n      // adding statements to.\n\n      for (var cur, sawDefault; tokType != _braceR;) {\n        if (tokType === _case || tokType === _default) {\n          var isCase = tokType === _case;\n          if (cur) finishNode(cur, \"SwitchCase\");\n          node.cases.push(cur = startNode());\n          cur.consequent = [];\n          next();\n          if (isCase) cur.test = parseExpression();\n          else {\n            if (sawDefault) raise(lastStart, \"Multiple default clauses\"); sawDefault = true;\n            cur.test = null;\n          }\n          expect(_colon);\n        } else {\n          if (!cur) unexpected();\n          cur.consequent.push(parseStatement());\n        }\n      }\n      if (cur) finishNode(cur, \"SwitchCase\");\n      next(); // Closing brace\n      labels.pop();\n      return finishNode(node, \"SwitchStatement\");\n\n    case _throw:\n      next();\n      if (newline.test(input.slice(lastEnd, tokStart)))\n        raise(lastEnd, \"Illegal newline after throw\");\n      node.argument = parseExpression();\n      semicolon();\n      return finishNode(node, \"ThrowStatement\");\n\n    case _try:\n      next();\n      node.block = parseBlock();\n      node.handler = null;\n      if (tokType === _catch) {\n        var clause = startNode();\n        next();\n        expect(_parenL);\n        clause.param = parseIdent();\n        if (strict && isStrictBadIdWord(clause.param.name))\n          raise(clause.param.start, \"Binding \" + clause.param.name + \" in strict mode\");\n        expect(_parenR);\n        clause.guard = null;\n        clause.body = parseBlock();\n        node.handler = finishNode(clause, \"CatchClause\");\n      }\n      node.guardedHandlers = empty;\n      node.finalizer = eat(_finally) ? parseBlock() : null;\n      if (!node.handler && !node.finalizer)\n        raise(node.start, \"Missing catch or finally clause\");\n      return finishNode(node, \"TryStatement\");\n\n    case _var:\n      next();\n      parseVar(node);\n      semicolon();\n      return finishNode(node, \"VariableDeclaration\");\n\n    case _while:\n      next();\n      node.test = parseParenExpression();\n      labels.push(loopLabel);\n      node.body = parseStatement();\n      labels.pop();\n      return finishNode(node, \"WhileStatement\");\n\n    case _with:\n      if (strict) raise(tokStart, \"'with' in strict mode\");\n      next();\n      node.object = parseParenExpression();\n      node.body = parseStatement();\n      return finishNode(node, \"WithStatement\");\n\n    case _braceL:\n      return parseBlock();\n\n    case _semi:\n      next();\n      return finishNode(node, \"EmptyStatement\");\n\n      // If the statement does not start with a statement keyword or a\n      // brace, it's an ExpressionStatement or LabeledStatement. We\n      // simply start parsing an expression, and afterwards, if the\n      // next token is a colon and the expression was a simple\n      // Identifier node, we switch to interpreting it as a label.\n\n    default:\n      var maybeName = tokVal, expr = parseExpression();\n      if (starttype === _name && expr.type === \"Identifier\" && eat(_colon)) {\n        for (var i = 0; i < labels.length; ++i)\n          if (labels[i].name === maybeName) raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n        var kind = tokType.isLoop ? \"loop\" : tokType === _switch ? \"switch\" : null;\n        labels.push({name: maybeName, kind: kind});\n        node.body = parseStatement();\n        labels.pop();\n        node.label = expr;\n        return finishNode(node, \"LabeledStatement\");\n      } else {\n        node.expression = expr;\n        semicolon();\n        return finishNode(node, \"ExpressionStatement\");\n      }\n    }\n  }\n\n  // Used for constructs like `switch` and `if` that insist on\n  // parentheses around their expression.\n\n  function parseParenExpression() {\n    expect(_parenL);\n    var val = parseExpression();\n    expect(_parenR);\n    return val;\n  }\n\n  // Parse a semicolon-enclosed block of statements, handling `\"use\n  // strict\"` declarations when `allowStrict` is true (used for\n  // function bodies).\n\n  function parseBlock(allowStrict) {\n    var node = startNode(), first = true, strict = false, oldStrict;\n    node.body = [];\n    expect(_braceL);\n    while (!eat(_braceR)) {\n      var stmt = parseStatement();\n      node.body.push(stmt);\n      if (first && allowStrict && isUseStrict(stmt)) {\n        oldStrict = strict;\n        setStrict(strict = true);\n      }\n      first = false;\n    }\n    if (strict && !oldStrict) setStrict(false);\n    return finishNode(node, \"BlockStatement\");\n  }\n\n  // Parse a regular `for` loop. The disambiguation code in\n  // `parseStatement` will already have parsed the init statement or\n  // expression.\n\n  function parseFor(node, init) {\n    node.init = init;\n    expect(_semi);\n    node.test = tokType === _semi ? null : parseExpression();\n    expect(_semi);\n    node.update = tokType === _parenR ? null : parseExpression();\n    expect(_parenR);\n    node.body = parseStatement();\n    labels.pop();\n    return finishNode(node, \"ForStatement\");\n  }\n\n  // Parse a `for`/`in` loop.\n\n  function parseForIn(node, init) {\n    node.left = init;\n    node.right = parseExpression();\n    expect(_parenR);\n    node.body = parseStatement();\n    labels.pop();\n    return finishNode(node, \"ForInStatement\");\n  }\n\n  // Parse a list of variable declarations.\n\n  function parseVar(node, noIn) {\n    node.declarations = [];\n    node.kind = \"var\";\n    for (;;) {\n      var decl = startNode();\n      decl.id = parseIdent();\n      if (strict && isStrictBadIdWord(decl.id.name))\n        raise(decl.id.start, \"Binding \" + decl.id.name + \" in strict mode\");\n      decl.init = eat(_eq) ? parseExpression(true, noIn) : null;\n      node.declarations.push(finishNode(decl, \"VariableDeclarator\"));\n      if (!eat(_comma)) break;\n    }\n    return node;\n  }\n\n  // ### Expression parsing\n\n  // These nest, from the most general expression type at the top to\n  // 'atomic', nondivisible expression types at the bottom. Most of\n  // the functions will simply let the function(s) below them parse,\n  // and, *if* the syntactic construct they handle is present, wrap\n  // the AST node that the inner parser gave them in another node.\n\n  // Parse a full expression. The arguments are used to forbid comma\n  // sequences (in argument lists, array literals, or object literals)\n  // or the `in` operator (in for loops initalization expressions).\n\n  function parseExpression(noComma, noIn) {\n    var expr = parseMaybeAssign(noIn);\n    if (!noComma && tokType === _comma) {\n      var node = startNodeFrom(expr);\n      node.expressions = [expr];\n      while (eat(_comma)) node.expressions.push(parseMaybeAssign(noIn));\n      return finishNode(node, \"SequenceExpression\");\n    }\n    return expr;\n  }\n\n  // Parse an assignment expression. This includes applications of\n  // operators like `+=`.\n\n  function parseMaybeAssign(noIn) {\n    var left = parseMaybeConditional(noIn);\n    if (tokType.isAssign) {\n      var node = startNodeFrom(left);\n      node.operator = tokVal;\n      node.left = left;\n      next();\n      node.right = parseMaybeAssign(noIn);\n      checkLVal(left);\n      return finishNode(node, \"AssignmentExpression\");\n    }\n    return left;\n  }\n\n  // Parse a ternary conditional (`?:`) operator.\n\n  function parseMaybeConditional(noIn) {\n    var expr = parseExprOps(noIn);\n    if (eat(_question)) {\n      var node = startNodeFrom(expr);\n      node.test = expr;\n      node.consequent = parseExpression(true);\n      expect(_colon);\n      node.alternate = parseExpression(true, noIn);\n      return finishNode(node, \"ConditionalExpression\");\n    }\n    return expr;\n  }\n\n  // Start the precedence parser.\n\n  function parseExprOps(noIn) {\n    return parseExprOp(parseMaybeUnary(), -1, noIn);\n  }\n\n  // Parse binary operators with the operator precedence parsing\n  // algorithm. `left` is the left-hand side of the operator.\n  // `minPrec` provides context that allows the function to stop and\n  // defer further parser to one of its callers when it encounters an\n  // operator that has a lower precedence than the set it is parsing.\n\n  function parseExprOp(left, minPrec, noIn) {\n    var prec = tokType.binop;\n    if (prec != null && (!noIn || tokType !== _in)) {\n      if (prec > minPrec) {\n        var node = startNodeFrom(left);\n        node.left = left;\n        node.operator = tokVal;\n        var op = tokType;\n        next();\n        node.right = parseExprOp(parseMaybeUnary(), prec, noIn);\n        var exprNode = finishNode(node, (op === _logicalOR || op === _logicalAND) ? \"LogicalExpression\" : \"BinaryExpression\");\n        return parseExprOp(exprNode, minPrec, noIn);\n      }\n    }\n    return left;\n  }\n\n  // Parse unary operators, both prefix and postfix.\n\n  function parseMaybeUnary() {\n    if (tokType.prefix) {\n      var node = startNode(), update = tokType.isUpdate;\n      node.operator = tokVal;\n      node.prefix = true;\n      tokRegexpAllowed = true;\n      next();\n      node.argument = parseMaybeUnary();\n      if (update) checkLVal(node.argument);\n      else if (strict && node.operator === \"delete\" &&\n               node.argument.type === \"Identifier\")\n        raise(node.start, \"Deleting local variable in strict mode\");\n      return finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    }\n    var expr = parseExprSubscripts();\n    while (tokType.postfix && !canInsertSemicolon()) {\n      var node = startNodeFrom(expr);\n      node.operator = tokVal;\n      node.prefix = false;\n      node.argument = expr;\n      checkLVal(expr);\n      next();\n      expr = finishNode(node, \"UpdateExpression\");\n    }\n    return expr;\n  }\n\n  // Parse call, dot, and `[]`-subscript expressions.\n\n  function parseExprSubscripts() {\n    return parseSubscripts(parseExprAtom());\n  }\n\n  function parseSubscripts(base, noCalls) {\n    if (eat(_dot)) {\n      var node = startNodeFrom(base);\n      node.object = base;\n      node.property = parseIdent(true);\n      node.computed = false;\n      return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\n    } else if (eat(_bracketL)) {\n      var node = startNodeFrom(base);\n      node.object = base;\n      node.property = parseExpression();\n      node.computed = true;\n      expect(_bracketR);\n      return parseSubscripts(finishNode(node, \"MemberExpression\"), noCalls);\n    } else if (!noCalls && eat(_parenL)) {\n      var node = startNodeFrom(base);\n      node.callee = base;\n      node.arguments = parseExprList(_parenR, false);\n      return parseSubscripts(finishNode(node, \"CallExpression\"), noCalls);\n    } else return base;\n  }\n\n  // Parse an atomic expression  either a single token that is an\n  // expression, an expression started by a keyword like `function` or\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n  // or `{}`.\n\n  function parseExprAtom() {\n    switch (tokType) {\n    case _this:\n      var node = startNode();\n      next();\n      return finishNode(node, \"ThisExpression\");\n    case _name:\n      return parseIdent();\n    case _num: case _string: case _regexp:\n      var node = startNode();\n      node.value = tokVal;\n      node.raw = input.slice(tokStart, tokEnd);\n      next();\n      return finishNode(node, \"Literal\");\n\n    case _null: case _true: case _false:\n      var node = startNode();\n      node.value = tokType.atomValue;\n      node.raw = tokType.keyword;\n      next();\n      return finishNode(node, \"Literal\");\n\n    case _parenL:\n      var tokStartLoc1 = tokStartLoc, tokStart1 = tokStart;\n      next();\n      var val = parseExpression();\n      val.start = tokStart1;\n      val.end = tokEnd;\n      if (options.locations) {\n        val.loc.start = tokStartLoc1;\n        val.loc.end = tokEndLoc;\n      }\n      if (options.ranges)\n        val.range = [tokStart1, tokEnd];\n      expect(_parenR);\n      return val;\n\n    case _bracketL:\n      var node = startNode();\n      next();\n      node.elements = parseExprList(_bracketR, true, true);\n      return finishNode(node, \"ArrayExpression\");\n\n    case _braceL:\n      return parseObj();\n\n    case _function:\n      var node = startNode();\n      next();\n      return parseFunction(node, false);\n\n    case _new:\n      return parseNew();\n\n    default:\n      unexpected();\n    }\n  }\n\n  // New's precedence is slightly tricky. It must allow its argument\n  // to be a `[]` or dot subscript expression, but not a call  at\n  // least, not without wrapping it in parentheses. Thus, it uses the\n\n  function parseNew() {\n    var node = startNode();\n    next();\n    node.callee = parseSubscripts(parseExprAtom(), true);\n    if (eat(_parenL)) node.arguments = parseExprList(_parenR, false);\n    else node.arguments = empty;\n    return finishNode(node, \"NewExpression\");\n  }\n\n  // Parse an object literal.\n\n  function parseObj() {\n    var node = startNode(), first = true, sawGetSet = false;\n    node.properties = [];\n    next();\n    while (!eat(_braceR)) {\n      if (!first) {\n        expect(_comma);\n        if (options.allowTrailingCommas && eat(_braceR)) break;\n      } else first = false;\n\n      var prop = {key: parsePropertyName()}, isGetSet = false, kind;\n      if (eat(_colon)) {\n        prop.value = parseExpression(true);\n        kind = prop.kind = \"init\";\n      } else if (options.ecmaVersion >= 5 && prop.key.type === \"Identifier\" &&\n                 (prop.key.name === \"get\" || prop.key.name === \"set\")) {\n        isGetSet = sawGetSet = true;\n        kind = prop.kind = prop.key.name;\n        prop.key = parsePropertyName();\n        if (tokType !== _parenL) unexpected();\n        prop.value = parseFunction(startNode(), false);\n      } else unexpected();\n\n      // getters and setters are not allowed to clash  either with\n      // each other or with an init property  and in strict mode,\n      // init properties are also not allowed to be repeated.\n\n      if (prop.key.type === \"Identifier\" && (strict || sawGetSet)) {\n        for (var i = 0; i < node.properties.length; ++i) {\n          var other = node.properties[i];\n          if (other.key.name === prop.key.name) {\n            var conflict = kind == other.kind || isGetSet && other.kind === \"init\" ||\n              kind === \"init\" && (other.kind === \"get\" || other.kind === \"set\");\n            if (conflict && !strict && kind === \"init\" && other.kind === \"init\") conflict = false;\n            if (conflict) raise(prop.key.start, \"Redefinition of property\");\n          }\n        }\n      }\n      node.properties.push(prop);\n    }\n    return finishNode(node, \"ObjectExpression\");\n  }\n\n  function parsePropertyName() {\n    if (tokType === _num || tokType === _string) return parseExprAtom();\n    return parseIdent(true);\n  }\n\n  // Parse a function declaration or literal (depending on the\n  // `isStatement` parameter).\n\n  function parseFunction(node, isStatement) {\n    if (tokType === _name) node.id = parseIdent();\n    else if (isStatement) unexpected();\n    else node.id = null;\n    node.params = [];\n    var first = true;\n    expect(_parenL);\n    while (!eat(_parenR)) {\n      if (!first) expect(_comma); else first = false;\n      node.params.push(parseIdent());\n    }\n\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldInFunc = inFunction, oldLabels = labels;\n    inFunction = true; labels = [];\n    node.body = parseBlock(true);\n    inFunction = oldInFunc; labels = oldLabels;\n\n    // If this is a strict mode function, verify that argument names\n    // are not repeated, and it does not try to bind the words `eval`\n    // or `arguments`.\n    if (strict || node.body.body.length && isUseStrict(node.body.body[0])) {\n      for (var i = node.id ? -1 : 0; i < node.params.length; ++i) {\n        var id = i < 0 ? node.id : node.params[i];\n        if (isStrictReservedWord(id.name) || isStrictBadIdWord(id.name))\n          raise(id.start, \"Defining '\" + id.name + \"' in strict mode\");\n        if (i >= 0) for (var j = 0; j < i; ++j) if (id.name === node.params[j].name)\n          raise(id.start, \"Argument name clash in strict mode\");\n      }\n    }\n\n    return finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n  }\n\n  // Parses a comma-separated list of expressions, and returns them as\n  // an array. `close` is the token type that ends the list, and\n  // `allowEmpty` can be turned on to allow subsequent commas with\n  // nothing in between them to be parsed as `null` (which is needed\n  // for array literals).\n\n  function parseExprList(close, allowTrailingComma, allowEmpty) {\n    var elts = [], first = true;\n    while (!eat(close)) {\n      if (!first) {\n        expect(_comma);\n        if (allowTrailingComma && options.allowTrailingCommas && eat(close)) break;\n      } else first = false;\n\n      if (allowEmpty && tokType === _comma) elts.push(null);\n      else elts.push(parseExpression(true));\n    }\n    return elts;\n  }\n\n  // Parse the next token as an identifier. If `liberal` is true (used\n  // when parsing properties), it will also convert keywords into\n  // identifiers.\n\n  function parseIdent(liberal) {\n    var node = startNode();\n    node.name = tokType === _name ? tokVal : (liberal && !options.forbidReserved && tokType.keyword) || unexpected();\n    tokRegexpAllowed = false;\n    next();\n    return finishNode(node, \"Identifier\");\n  }\n\n});\n","import * as ESTree from 'estree';\nimport { MyObject } from './MyObject';\n\n/**\n * Class for a state.\n * @param {!MyObject} node AST node for the state.\n * @param {!MyObject} scope Scope object for the state.\n * @constructor\n */\nexport class MyState {\n  [key: string]: any;\n\n  node: ESTree.BaseNode;\n  scope: MyObject;\n\n  constructor(node: ESTree.BaseNode, scope: MyObject) {\n    this.node = node;\n    this.scope = scope;\n  }\n}\n","import { Interpreter } from './Interpreter';\n\n/**\n * Class for an object.\n * @param {MyObject} proto Prototype object or null.\n * @constructor\n */\nexport class MyObject {\n  [key: string]: any;\n\n  getter: any;\n  setter: any;\n  properties: any;\n\n  constructor(proto) {\n    this.getter = Object.create(null);\n    this.setter = Object.create(null);\n    this.properties = Object.create(null);\n    this.proto = proto;\n  }\n\n  /** @type {MyObject} */\n  proto: MyObject = null;\n\n  /** @type {boolean} */\n  isObject = true;\n\n  /** @type {string} */\n  class = 'Object';\n\n  /** @type {Date|RegExp|boolean|number|string|undefined|null} */\n  data: Date | RegExp | boolean | number | string | undefined | null = null;\n\n  /**\n   * Convert this object into a string.\n   * @return {string} String value.\n   * @override\n   */\n  toString() {\n    if (this.class === 'Array') {\n      // Array\n      var cycles = Interpreter.toStringCycles_;\n      cycles.push(this);\n      try {\n        var strs = [];\n        for (var i = 0; i < this.properties.length; i++) {\n          var value = this.properties[i];\n          strs[i] = value && value.isObject && cycles.indexOf(value) !== -1 ? '...' : value;\n        }\n      } finally {\n        cycles.pop();\n      }\n      return strs.join(',');\n    }\n    if (this.class === 'Error') {\n      var cycles = Interpreter.toStringCycles_;\n      if (cycles.indexOf(this) !== -1) {\n        return '[object Error]';\n      }\n      var name, message;\n      // Bug: Does not support getters and setters for name or message.\n      var obj = <MyObject>this;\n      do {\n        if ('name' in obj.properties) {\n          name = obj.properties['name'];\n          break;\n        }\n      } while ((obj = obj.proto));\n      var obj = <MyObject>this;\n      do {\n        if ('message' in obj.properties) {\n          message = obj.properties['message'];\n          break;\n        }\n      } while ((obj = obj.proto));\n      cycles.push(this);\n      try {\n        name = name && name.toString();\n        message = message && message.toString();\n      } finally {\n        cycles.pop();\n      }\n      return message ? name + ': ' + message : String(name);\n    }\n\n    // RegExp, Date, and boxed primitives.\n    if (this.data !== null) {\n      return String(this.data);\n    }\n\n    return '[object ' + this.class + ']';\n  }\n\n  /**\n   * Return the object's value.\n   * @return {MyValue} Value.\n   * @override\n   */\n  valueOf() {\n    if (this.data === undefined || this.data === null || this.data instanceof RegExp) {\n      return this; // An Object.\n    }\n    if (this.data instanceof Date) {\n      return this.data.valueOf(); // Milliseconds.\n    }\n    return /** @type {(boolean|number|string)} */ this.data; // Boxed primitive.\n  }\n}\n"],"sourceRoot":""}